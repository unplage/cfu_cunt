<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>èŒè½è®¡æ•°åŠ©æ‰‹ï¼ˆEdge+GH Pages ç»ˆæå¯ç”¨ç‰ˆï¼‰</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #f8fafc; }
    .container { max-width: 1000px; margin: 0 auto; }
    h1 { text-align: center; color: #1d4ed8; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
    @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } }
    .card { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
    h2 { color: #1d4ed8; margin: 0 0 16px; border-bottom: 2px solid #3b82f6; padding-bottom: 8px; }
    #camera { height: 300px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border: 2px dashed #cbd5e1; border-radius: 8px; font-style: italic; color: #94a3b8; }
    button {
      padding: 12px 24px;
      background: #1d4ed8;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      margin: 0 8px 12px;
    }
    button:hover { background: #1e40af; }
    canvas { width: 100%; height: auto; border-radius: 6px; border: 1px #e2e8f0 solid; display: block; background: #fff; }
    #status { text-align: center; font-weight: 600; padding: 12px; margin: 12px 0; }
    .good { color: #10b981; }
    .warn { color: #f59e0b; }
    .bad { color: #ef4444; }
    .result-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px #e2e8f0 solid; }
  </style>
</head>
<body>
<div class="container">
  <h1>ğŸ”¬ èŒè½è®¡æ•°åŠ©æ‰‹ï¼ˆEdge + GitHub Pages å¯ç”¨ç‰ˆï¼‰</h1>
  <p style="text-align:center;color:#64748b;">ç‚¹å‡»ã€æ‹ç…§ã€‘å¯åŠ¨æ‘„åƒå¤´ â†’ å¯¹å‡†å¹³æ¿ â†’ è‡ªåŠ¨åˆ†æå¹¶æ ‡è“ç‚¹</p>

  <div class="grid">
    <!-- æ§åˆ¶åŒº -->
    <div class="card">
      <h2>æ‹æ‘„å›¾åƒ</h2>
      <div id="camera">ğŸ“· ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯åŠ¨æ‘„åƒå¤´</div>
      <button id="btn-capture">ğŸ“¸ æ‹ç…§</button>
      <button id="btn-upload">ğŸ“¤ ä¸Šä¼ </button>
      <div id="status" class="warn">è¯·å…ˆç‚¹å‡»ã€æ‹ç…§ã€‘å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <!-- ç»“æœåŒº -->
    <div class="card">
      <h2>è®¡æ•°ç»“æœ</h2>
      <div style="background:#f0f9ff;padding:16px;border-radius:8px;">
        <div class="result-row"><span>èŒè½æ•°ï¼š</span><span id="count">0</span></div>
        <div class="result-row"><span>çŠ¶æ€ï¼š</span><span id="status-text">ç©ºé—²</span></div>
      </div>
      <h3 style="margin:20px 0 10px;">è¯†åˆ«ç»“æœ</h3>
      <canvas id="canvas-out" height="300"></canvas>
    </div>
  </div>
</div>

<script>
let cvLoaded = false;
let videoElement = null;
let videoStream = null;

const canvasOut = document.getElementById('canvas-out');
const ctx = canvasOut.getContext('2d');
const countEl = document.getElementById('count');
const statusEl = document.getElementById('status');
const statusTextEl = document.getElementById('status-text');
const btnCapture = document.getElementById('btn-capture');
const btnUpload = document.getElementById('btn-upload');
const cameraDiv = document.getElementById('camera');

// âœ… æ ¸å¿ƒï¼šç«‹å³ç»‘å®šï¼Œä¸ç­‰å¾…ä»»ä½•åŠ è½½
btnCapture.addEventListener('click', async () => {
  statusEl.textContent = 'ğŸ“· è¯·æ±‚æ‘„åƒå¤´æƒé™...';
  statusEl.className = 'warn';
  statusTextEl.textContent = 'è¯·æ±‚ä¸­';

  try {
    // ğŸ”¥ å…³é”®ï¼šå¿…é¡»åœ¨ç”¨æˆ·ç‚¹å‡»äº‹ä»¶åŒæ­¥ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ getUserMedia
    if (!videoStream) {
      videoStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment', width: 1280, height: 720 }
      });
    }

    if (!videoElement) {
      videoElement = document.createElement('video');
      videoElement.srcObject = videoStream;
      videoElement.autoplay = true;
      videoElement.playsInline = true;
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.objectFit = 'cover';
      
      // âœ… Edge å¿…é¡»é™éŸ³æ‰èƒ½è‡ªåŠ¨æ’­æ”¾
      videoElement.muted = true;
      await videoElement.play();
    }

    cameraDiv.innerHTML = '';
    cameraDiv.appendChild(videoElement);
    statusEl.textContent = 'âœ… ç›¸æœºå·²å°±ç»ªï¼Œè¯·å¯¹å‡†å¹³æ¿';
    statusEl.className = 'good';
    statusTextEl.textContent = 'ç›¸æœºè¿è¡Œä¸­';

    // ç­‰å¾…è§†é¢‘å¸§ç¨³å®šï¼ˆ1ç§’ï¼‰
    await new Promise(r => setTimeout(r, 1000));

    // æ‹ç…§
    statusEl.textContent = 'ğŸ“¸ æ­£åœ¨æ•è·å›¾åƒ...';
    statusEl.className = 'warn';
    statusTextEl.textContent = 'æ•è·ä¸­';

    const snapCanvas = document.createElement('canvas');
    snapCanvas.width = videoElement.videoWidth || 640;
    snapCanvas.height = videoElement.videoHeight || 480;
    const snapCtx = snapCanvas.getContext('2d');
    snapCtx.drawImage(videoElement, 0, 0, snapCanvas.width, snapCanvas.height);
    
    const blob = await new Promise(resolve => snapCanvas.toBlob(resolve, 'image/jpeg', 0.8));
    await processImage(blob);

  } catch (err) {
    console.error('æ‹ç…§æµç¨‹é”™è¯¯:', err);
    statusEl.textContent = `âŒ å¤±è´¥: ${err.name} - ${err.message}`;
    statusEl.className = 'bad';
    statusTextEl.textContent = 'æ‹ç…§å¼‚å¸¸';
    if (err.name === 'NotAllowedError') {
      alert('âš ï¸ è¯·æ‰‹åŠ¨å…è®¸æ‘„åƒå¤´æƒé™ï¼šç‚¹å‡»åœ°å€æ é”å›¾æ ‡ â†’ â€œæ‘„åƒå¤´â€ â†’ é€‰æ‹©â€œå…è®¸â€');
    }
  }
});

btnUpload.addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = async (e) => {
    if (e.target.files[0]) {
      try {
        statusEl.textContent = 'ğŸ“¤ å¤„ç†ä¸­...';
        statusEl.className = 'warn';
        await processImage(e.target.files[0]);
      } catch (err) {
        statusEl.textContent = `âŒ ä¸Šä¼ å¤±è´¥: ${err.message}`;
        statusEl.className = 'bad';
        console.error('ä¸Šä¼ é”™è¯¯:', err);
      }
    }
  };
  input.click();
});

async function processImage(file) {
  const img = new Image();
  img.src = URL.createObjectURL(file);
  await new Promise(r => img.onload = r);

  canvasOut.width = img.width;
  canvasOut.height = img.height;
  ctx.clearRect(0, 0, canvasOut.width, canvasOut.height);
  ctx.drawImage(img, 0, 0);

  let colonyCount = 0;
  let centers = [];

  // çº¯JSæ£€æµ‹ï¼ˆä¿è¯æ— ä¾èµ–ä¹Ÿèƒ½å·¥ä½œï¼‰
  ({ count: colonyCount, centers }) = detectColonies(img);

  countEl.textContent = colonyCount;
  statusEl.textContent = `âœ… è®¡æ•°å®Œæˆï¼š${colonyCount} ä¸ªèŒè½`;
  statusEl.className = 'good';
  statusTextEl.textContent = 'è®¡æ•°å®Œæˆ';

  // ğŸ”µ æ ‡ä¸­å¿ƒè“ç‚¹
  ctx.fillStyle = 'rgba(30, 144, 255, 0.95)';
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  for (const [x, y] of centers) {
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }
}

function detectColonies(img) {
  const c = document.createElement('canvas');
  c.width = img.width; c.height = img.height;
  const ctx2 = c.getContext('2d');
  ctx2.drawImage(img, 0, 0);
  const d = ctx2.getImageData(0, 0, c.width, c.height).data;
  const w = c.width, h = c.height;
  const visited = new Uint8Array(w * h);
  const centers = [];
  let count = 0;

  const pixels = [];
  for (let i = 0; i < d.length; i += 4) {
    const r = d[i], g = d[i+1], b = d[i+2];
    pixels.push(0.299*r + 0.587*g + 0.114*b);
  }

  const sorted = [...pixels].sort((a,b) => a-b);
  const thresh = sorted[Math.floor(sorted.length * 0.6)];

  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      const idx = y * w + x;
      if (pixels[idx] > thresh && visited[idx] === 0) {
        const stack = [[x, y]];
        let sumX = 0, sumY = 0, area = 0;
        while (stack.length) {
          const [cx, cy] = stack.pop();
          const i = cy * w + cx;
          if (i < 0 || i >= w*h || visited[i] || pixels[i] <= thresh) continue;
          visited[i] = 1;
          sumX += cx;
          sumY += cy;
          area++;
          stack.push([cx+1,cy], [cx-1,cy], [cx,cy+1], [cx,cy-1]);
        }
        if (area >= 35 && area <= 800) {
          centers.push([sumX / area, sumY / area]);
          count++;
        }
      }
    }
  }

  return { count, centers };
}
</script>
</body>
</html>
