<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>èŒè½è®¡æ•°å™¨ Â· YOLOç‰ˆ</title>
    
    <!-- ONNX Runtime for YOLO -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    
    <style>
        :root {
            --primary: #3b82f6;
            --primary-dark: #1d4ed8;
            --secondary: #64748b;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #06b6d4;
            --bg: #0f172a;
            --card: #1e293b;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --roi-color: rgba(255, 215, 0, 0.3);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; overflow-x: hidden; }
        
        .splash { position: fixed; inset: 0; background: linear-gradient(135deg, #1e3a8a 0%, #0f172a 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s; }
        .splash.hidden { opacity: 0; pointer-events: none; }
        .splash-icon { font-size: 100px; margin-bottom: 20px; animation: bounce 2s infinite; }
        @keyframes bounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-20px)} }
        .splash-text { font-size: 1.8rem; font-weight: 700; margin-bottom: 10px; }
        .splash-subtitle { color: var(--text-muted); margin-bottom: 30px; }
        .loading-bar { width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; }
        .loading-progress { height: 100%; background: var(--primary); width: 0%; animation: loading 2s ease-in-out infinite; }
        @keyframes loading { 0%{width:0%;margin-left:0%} 50%{width:50%;margin-left:25%} 100%{width:0%;margin-left:100%} }
        
        .app { max-width: 100vw; min-height: 100vh; display: flex; flex-direction: column; }
        header { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); padding: 20px; text-align: center; box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3); position: sticky; top: 0; z-index: 100; }
        h1 { font-size: 1.6rem; font-weight: 700; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .version-badge { background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 12px; font-size: 0.7rem; }
        
        main { flex: 1; padding: 20px; display: flex; flex-direction: column; gap: 20px; max-width: 1200px; margin: 0 auto; width: 100%; }
        
        .upload-card { background: var(--card); border-radius: 24px; padding: 40px 30px; text-align: center; border: 2px dashed var(--secondary); transition: all 0.3s; cursor: pointer; }
        .upload-card:hover, .upload-card.active { border-color: var(--primary); background: rgba(59, 130, 246, 0.1); transform: translateY(-2px); }
        .upload-icon { font-size: 72px; margin-bottom: 20px; opacity: 0.9; }
        .upload-title { font-size: 1.4rem; margin-bottom: 10px; font-weight: 600; }
        .upload-subtitle { color: var(--text-muted); margin-bottom: 30px; font-size: 0.95rem; }
        .upload-tips { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-bottom: 25px; }
        .tip-item { display: flex; align-items: center; gap: 6px; font-size: 0.85rem; color: var(--text-muted); background: var(--bg); padding: 6px 12px; border-radius: 20px; }
        .btn-group { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
        .btn { padding: 14px 28px; border: none; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5); }
        .btn-secondary { background: var(--secondary); color: white; }
        .btn-secondary:hover { background: #475569; }
        input[type="file"] { display: none; }
        
        .viewer { display: none; flex-direction: column; gap: 20px; animation: fadeIn 0.5s; }
        .viewer.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .control-panel { background: var(--card); border-radius: 20px; padding: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .control-section { display: flex; flex-direction: column; gap: 12px; }
        .section-title { font-size: 0.9rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .slider-group { display: flex; flex-direction: column; gap: 8px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; }
        .slider-label { font-size: 0.9rem; }
        .slider-value { background: var(--bg); padding: 4px 10px; border-radius: 6px; font-size: 0.85rem; font-weight: 600; color: var(--primary); min-width: 40px; text-align: center; }
        input[type="range"] { width: 100%; height: 6px; -webkit-appearance: none; background: var(--bg); border-radius: 3px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: var(--primary); border-radius: 50%; cursor: pointer; transition: transform 0.2s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        
        select { width: 100%; padding: 8px; border-radius: 6px; background: var(--bg); color: var(--text); border: 1px solid var(--secondary); font-size: 0.9rem; }
        
        .action-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .btn-small { padding: 10px 16px; font-size: 0.85rem; }
        .btn-success { background: var(--success); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-info { background: var(--info); color: white; }
        .btn-outline { background: transparent; border: 1px solid var(--secondary); color: var(--text); }
        
        .mode-indicator { display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: rgba(59, 130, 246, 0.2); color: var(--primary); border-radius: 20px; font-size: 0.9rem; font-weight: 600; }
        .mode-indicator.manual { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .mode-indicator.roi { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        
        .image-wrapper { position: relative; background: var(--card); border-radius: 20px; overflow: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.4); max-height: 70vh; }
        .canvas-container { position: relative; display: inline-block; min-width: 100%; }
        #mainCanvas { display: block; width: auto; height: auto; background: #1e293b; max-width: none; }
        .overlay-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .roi-marker { position: absolute; border: 3px solid gold; border-radius: 50%; background: var(--roi-color); pointer-events: none; box-shadow: 0 0 0 2px rgba(0,0,0,0.3); display: none; }
        
        .colony-marker { position: absolute; transform: translate(-50%, -50%); pointer-events: auto; cursor: pointer; z-index: 10; transition: all 0.2s; }
        .marker-center { width: 6px; height: 6px; background: #00ff88; border: 1px solid white; border-radius: 50%; box-shadow: 0 1px 4px rgba(0,0,0,0.5); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .marker-circle { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #ff4757; border-radius: 50%; opacity: 0.7; }
        .colony-marker:hover { z-index: 20; transform: translate(-50%, -50%) scale(1.3); }
        .colony-marker:hover .marker-center { background: #ff4757; }
        .colony-marker.manual .marker-center { background: #ffd700; }
        .colony-marker.manual .marker-circle { border-color: #ffd700; }
        .marker-tooltip { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: white; padding: 6px 10px; border-radius: 6px; font-size: 11px; white-space: nowrap; opacity: 0; transition: opacity 0.2s; pointer-events: none; margin-bottom: 5px; z-index: 30; }
        .colony-marker:hover .marker-tooltip { opacity: 1; }
        
        .stats-panel { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; }
        .stat-box { background: var(--card); border-radius: 16px; padding: 20px; text-align: center; border: 1px solid rgba(255,255,255,0.1); transition: transform 0.2s; }
        .stat-box:hover { transform: translateY(-2px); border-color: var(--primary); }
        .stat-number { font-size: 2.2rem; font-weight: 700; color: var(--primary); display: block; line-height: 1; }
        .stat-label { font-size: 0.85rem; color: var(--text-muted); margin-top: 8px; }
        .stat-box.success .stat-number { color: var(--success); }
        .stat-box.warning .stat-number { color: var(--warning); }
        .stat-box.info .stat-number { color: var(--info); }
        
        .loading-overlay { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(10px); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 9998; }
        .loading-overlay.active { display: flex; }
        .spinner { width: 60px; height: 60px; border: 4px solid rgba(59, 130, 246, 0.2); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { margin-top: 20px; font-size: 1.1rem; color: var(--text); }
        .loading-subtext { margin-top: 10px; font-size: 0.9rem; color: var(--text-muted); }
        
        .toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px); background: var(--card); color: var(--text); padding: 16px 24px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.1); opacity: 0; transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55); z-index: 10000; display: flex; align-items: center; gap: 10px; font-weight: 500; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        
        .algo-info { background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--primary); padding: 12px 16px; border-radius: 0 8px 8px 0; font-size: 0.85rem; color: var(--text-muted); }
        .param-tip { font-size: 0.75rem; color: var(--success); margin-top: 4px; }
        
        .model-status { display: inline-flex; align-items: center; gap: 6px; font-size: 0.8rem; padding: 4px 10px; border-radius: 12px; background: var(--bg); }
        .model-status.ready { color: var(--success); }
        .model-status.loading { color: var(--warning); animation: pulse 1.5s infinite; }
        .model-status.error { color: var(--danger); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        @media (max-width: 768px) { h1 { font-size: 1.3rem; } .upload-title { font-size: 1.2rem; } .control-panel { grid-template-columns: 1fr; } .stats-panel { grid-template-columns: repeat(2, 1fr); } }
    </style>
</head>
<body>
    <div class="splash" id="splash">
        <div class="splash-icon">ğŸ”¬</div>
        <div class="splash-text">èŒè½è®¡æ•°å™¨ Â· YOLOç‰ˆ</div>
        <div class="splash-subtitle">åŠ è½½YOLOv8æ¨¡å‹ä¸­...</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>
    
    <div class="app">
        <header>
            <h1><span>ğŸ”¬</span><span>èŒè½è®¡æ•°å™¨ Pro</span><span class="version-badge">YOLO</span></h1>
            <div style="margin-top: 8px; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                <span class="model-status loading" id="modelStatus">
                    <span>â³</span><span>æ¨¡å‹åŠ è½½ä¸­...</span>
                </span>
            </div>
        </header>
        
        <main>
            <div class="upload-card" id="uploadCard">
                <div class="upload-icon">ğŸ“¤</div>
                <div class="upload-title">æ‹–æ”¾å›¾ç‰‡æˆ–ç‚¹å‡»ä¸Šä¼ </div>
                <div class="upload-subtitle">JPG / PNG / WEBP Â· æ”¯æŒYOLOè‡ªåŠ¨æ£€æµ‹</div>
                <div class="upload-tips">
                    <div class="tip-item"><span>ğŸ¤–</span><span>YOLOæ™ºèƒ½è¯†åˆ«</span></div>
                    <div class="tip-item"><span>ğŸ’¡</span><span>å…‰çº¿å‡åŒ€</span></div>
                    <div class="tip-item"><span>ğŸ¯</span><span>å¯ä½¿ç”¨ROI</span></div>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()"><span>ğŸ“</span><span>é€‰æ‹©æ–‡ä»¶</span></button>
                    <button class="btn btn-secondary" onclick="document.getElementById('cameraInput').click()"><span>ğŸ“·</span><span>æ‹ç…§</span></button>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                <input type="file" id="cameraInput" accept="image/*" capture="environment">
            </div>
            
            <div class="viewer" id="viewer">
                <div class="control-panel">
                    <div class="control-section">
                        <div class="section-title">ğŸ¤– YOLOæ£€æµ‹å‚æ•°</div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">ç½®ä¿¡åº¦é˜ˆå€¼</span><span class="slider-value" id="confValue">0.25</span></div>
                            <input type="range" id="confThreshold" min="0.1" max="0.9" value="0.25" step="0.05">
                            <div class="param-tip">æ¨è0.2-0.3ï¼ˆè¶Šä½æ£€æµ‹è¶Šå¤šï¼‰</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">IoUé˜ˆå€¼ï¼ˆNMSï¼‰</span><span class="slider-value" id="iouValue">0.45</span></div>
                            <input type="range" id="iouThreshold" min="0.1" max="0.9" value="0.45" step="0.05">
                            <div class="param-tip">å»é™¤é‡å æ¡†ï¼Œæ¨è0.4-0.5</div>
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">è¾“å…¥å°ºå¯¸</span></div>
                            <select id="inputSize">
                                <option value="640" selected>640x640ï¼ˆæ¨èï¼‰</option>
                                <option value="320">320x320ï¼ˆå¿«é€Ÿï¼‰</option>
                                <option value="1280">1280x1280ï¼ˆç²¾å‡†ï¼‰</option>
                            </select>
                        </div>
                        <div class="algo-info">
                            ä½¿ç”¨YOLOv8næ¨¡å‹è¿›è¡ŒèŒè½æ£€æµ‹ï¼Œè‡ªåŠ¨è¯†åˆ«åœ†å½¢èŒè½ç‰¹å¾
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">ğŸ–¼ï¸ é¢„å¤„ç† / ROI</div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">å¯¹æ¯”åº¦å¢å¼º</span><span class="slider-value" id="contrastValue">1.0</span></div>
                            <input type="range" id="contrast" min="1.0" max="2.0" value="1.0" step="0.1">
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">äº®åº¦è°ƒæ•´</span><span class="slider-value" id="brightnessValue">0</span></div>
                            <input type="range" id="brightness" min="-50" max="50" value="0" step="5">
                        </div>
                        <div class="action-buttons">
                            <button class="btn btn-warning btn-small" id="selectRoiBtn">ğŸ¯ é€‰æ‹©åŸ¹å…»çš¿</button>
                            <button class="btn btn-outline btn-small" id="clearRoiBtn">ğŸ—‘ï¸ æ¸…é™¤ROI</button>
                        </div>
                        <div class="mode-indicator" id="roiIndicator" style="display: none;"><span>â­•</span><span>ROIå·²è®¾å®š</span></div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">ğŸ“Š åå¤„ç† / æ˜¾ç¤º</div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">æœ€å°èŒè½åŠå¾„(px)</span><span class="slider-value" id="minRadiusValue">3</span></div>
                            <input type="range" id="minRadiusFilter" min="1" max="20" value="3" step="1">
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">æœ€å¤§èŒè½åŠå¾„(px)</span><span class="slider-value" id="maxRadiusValue">50</span></div>
                            <input type="range" id="maxRadiusFilter" min="20" max="100" value="50" step="1">
                        </div>
                        <div class="slider-group">
                            <div class="slider-header"><span class="slider-label">å›¾åƒç¼©æ”¾</span><span class="slider-value" id="zoomValue">1.00</span></div>
                            <input type="range" id="zoomSlider" min="0.05" max="3.0" value="1.0" step="0.05">
                        </div>
                        <div class="action-buttons">
                            <button class="btn btn-primary btn-small" id="analyzeBtn">ğŸ”„ é‡æ–°åˆ†æ</button>
                            <button class="btn btn-success btn-small" id="addModeBtn">â• æ‰‹åŠ¨æ·»åŠ </button>
                            <button class="btn btn-info btn-small" id="toggleCirclesBtn">â­• æ˜¾éšåœ†åœˆ</button>
                            <button class="btn btn-outline btn-small" id="resetParamsBtn">â†º æ¢å¤é»˜è®¤</button>
                            <button class="btn btn-outline btn-small" id="exportImgBtn">ğŸ“¸ å¯¼å‡ºå›¾ç‰‡</button>
                            <button class="btn btn-danger btn-small" id="clearBtn">ğŸ—‘ï¸ æ¸…ç©º</button>
                            <button class="btn btn-outline btn-small" id="backBtn">â†©ï¸ æ–°å›¾ç‰‡</button>
                        </div>
                    </div>
                </div>
                
                <div class="image-wrapper" id="imageWrapper">
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="mainCanvas"></canvas>
                        <div class="overlay-layer" id="overlayLayer">
                            <div id="roiVisual" class="roi-marker"></div>
                        </div>
                    </div>
                </div>
                
                <div class="stats-panel">
                    <div class="stat-box"><span class="stat-number" id="statTotal">0</span><div class="stat-label">æ€»èŒè½æ•°</div></div>
                    <div class="stat-box success"><span class="stat-number" id="statAuto">0</span><div class="stat-label">YOLOæ£€æµ‹</div></div>
                    <div class="stat-box warning"><span class="stat-number" id="statManual">0</span><div class="stat-label">æ‰‹åŠ¨æ·»åŠ </div></div>
                    <div class="stat-box info"><span class="stat-number" id="statAvgRadius">0</span><div class="stat-label">å¹³å‡åŠå¾„(px)</div></div>
                </div>
            </div>
        </main>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">YOLOåˆ†æä¸­...</div>
        <div class="loading-subtext">ç¥ç»ç½‘ç»œæ¨ç† + NMSåå¤„ç†</div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // å…¨å±€çŠ¶æ€
        let session = null; // ONNX Runtime session
        let modelLoaded = false;
        let currentImage = null;
        let colonies = [];
        let isAddMode = false;
        let showCircles = true;
        let roiCenter = null;
        let roiRadius = null;
        let isRoiMode = false;
        let roiStart = null;
        
        // æ¨¡å‹é…ç½® - ä½¿ç”¨å…¬å…±CDNä¸Šçš„YOLOv8næ¨¡å‹ï¼ˆä½ éœ€è¦æ›¿æ¢ä¸ºå®é™…çš„èŒè½æ£€æµ‹æ¨¡å‹ï¼‰
        // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨çš„æ˜¯é€šç”¨YOLOv8nï¼Œå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨é’ˆå¯¹èŒè½è®­ç»ƒçš„ä¸“ä¸šæ¨¡å‹
        const MODEL_URL = 'https://huggingface.co/Xenova/yolov8-coco/resolve/main/yolov8n.onnx';
        // å¤‡ç”¨ï¼šä½¿ç”¨æ›´å°çš„æ¨¡å‹æˆ–è‡ªå®šä¹‰æ¨¡å‹URL
        // const MODEL_URL = 'https://your-domain.com/colony-yolov8n.onnx';
        
        const uploadCard = document.getElementById('uploadCard');
        const viewer = document.getElementById('viewer');
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const overlayLayer = document.getElementById('overlayLayer');
        const roiVisual = document.getElementById('roiVisual');
        const imageWrapper = document.getElementById('imageWrapper');
        const modelStatus = document.getElementById('modelStatus');
        
        const defaultParams = { 
            confThreshold: 0.25, 
            iouThreshold: 0.45, 
            inputSize: 640,
            contrast: 1.0, 
            brightness: 0, 
            minRadiusFilter: 3,
            maxRadiusFilter: 50,
            zoom: 1.0 
        };
        
        // åˆå§‹åŒ–YOLOæ¨¡å‹
        async function initYOLO() {
            try {
                console.log('Loading YOLO model...');
                // é…ç½®ONNX Runtime
                const ortConfig = {
                    executionProviders: ['wasm'], // ä½¿ç”¨WebAssemblyåç«¯ï¼Œå…¼å®¹æ€§å¥½
                    graphOptimizationLevel: 'all',
                    wasmOptions: {
                        numThreads: navigator.hardwareConcurrency || 4,
                        simd: true
                    }
                };
                
                // å°è¯•åŠ è½½æ¨¡å‹
                session = await ort.InferenceSession.create(MODEL_URL, ortConfig);
                modelLoaded = true;
                
                // æ›´æ–°UIçŠ¶æ€
                modelStatus.className = 'model-status ready';
                modelStatus.innerHTML = '<span>âœ…</span><span>YOLOæ¨¡å‹å°±ç»ª</span>';
                document.querySelector('.splash-subtitle').textContent = 'YOLOv8æ¨¡å‹åŠ è½½å®Œæˆ';
                
                setTimeout(() => {
                    document.getElementById('splash').classList.add('hidden');
                }, 800);
                
                console.log('YOLO model loaded successfully');
            } catch (error) {
                console.error('Failed to load model:', error);
                modelStatus.className = 'model-status error';
                modelStatus.innerHTML = '<span>âŒ</span><span>æ¨¡å‹åŠ è½½å¤±è´¥</span>';
                document.querySelector('.splash-subtitle').textContent = 'æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•';
                
                showToast('æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }
        
        // å¯åŠ¨æ¨¡å‹åŠ è½½
        initYOLO();
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('fileInput').addEventListener('change', handleFile);
            document.getElementById('cameraInput').addEventListener('change', handleFile);
            
            uploadCard.addEventListener('dragover', (e) => { e.preventDefault(); uploadCard.classList.add('active'); });
            uploadCard.addEventListener('dragleave', () => uploadCard.classList.remove('active'));
            uploadCard.addEventListener('drop', (e) => { 
                e.preventDefault(); 
                uploadCard.classList.remove('active'); 
                if (e.dataTransfer.files.length) processFile(e.dataTransfer.files[0]); 
            });
            
            // æ»‘å—äº‹ä»¶
            ['confThreshold', 'iouThreshold', 'contrast', 'brightness', 'minRadiusFilter', 'maxRadiusFilter'].forEach(id => {
                document.getElementById(id).addEventListener('input', (e) => {
                    const displayId = id.replace('Threshold', '').replace('Filter', '') + 'Value';
                    const el = document.getElementById(displayId) || document.getElementById(id + 'Value');
                    if (el) el.textContent = e.target.value;
                });
            });
            
            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                document.getElementById('zoomValue').textContent = parseFloat(e.target.value).toFixed(2);
                applyZoom();
            });
            
            // æŒ‰é’®
            document.getElementById('analyzeBtn').addEventListener('click', analyzeImage);
            document.getElementById('addModeBtn').addEventListener('click', toggleAddMode);
            document.getElementById('toggleCirclesBtn').addEventListener('click', toggleCircles);
            document.getElementById('clearBtn').addEventListener('click', clearAll);
            document.getElementById('backBtn').addEventListener('click', resetApp);
            document.getElementById('selectRoiBtn').addEventListener('click', enterRoiMode);
            document.getElementById('clearRoiBtn').addEventListener('click', clearRoi);
            document.getElementById('exportImgBtn').addEventListener('click', exportImage);
            document.getElementById('resetParamsBtn').addEventListener('click', resetToDefault);
            
            // Canvasäº‹ä»¶
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', cancelRoiDraw);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', cancelRoiDraw);
        });
        
        function handleFile(e) { 
            if (e.target.files.length) processFile(e.target.files[0]); 
        }
        
        function processFile(file) {
            if (!file.type.startsWith('image/')) { 
                showToast('âŒ è¯·é€‰æ‹©å›¾ç‰‡'); 
                return; 
            }
            const reader = new FileReader();
            reader.onload = (e) => { 
                const img = new Image(); 
                img.onload = () => { 
                    currentImage = img; 
                    displayImage(img); 
                    analyzeImage(); 
                }; 
                img.src = e.target.result; 
            };
            reader.readAsDataURL(file);
        }
        
        function displayImage(img) {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            canvas.dataset.origWidth = img.width;
            canvas.dataset.origHeight = img.height;
            
            const containerWidth = imageWrapper.clientWidth;
            let fitScale = containerWidth / img.width;
            fitScale = Math.min(3.0, Math.max(0.05, fitScale));
            document.getElementById('zoomSlider').value = fitScale.toFixed(2);
            document.getElementById('zoomValue').textContent = fitScale.toFixed(2);
            applyZoom();
            
            uploadCard.style.display = 'none';
            viewer.classList.add('active');
        }
        
        function applyZoom() {
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            canvas.style.width = (canvas.width * zoom) + 'px';
            canvas.style.height = (canvas.height * zoom) + 'px';
            renderMarkers();
        }
        
        function resetToDefault() {
            Object.keys(defaultParams).forEach(key => {
                const el = document.getElementById(key === 'zoom' ? 'zoomSlider' : 
                           key === 'minRadiusFilter' ? 'minRadiusFilter' :
                           key === 'maxRadiusFilter' ? 'maxRadiusFilter' : key);
                if (el) {
                    el.value = defaultParams[key];
                    const displayId = key.replace('Threshold', '').replace('Filter', '') + 'Value';
                    const displayEl = document.getElementById(displayId) || document.getElementById(key + 'Value');
                    if (displayEl) displayEl.textContent = defaultParams[key];
                }
            });
            
            if (currentImage) {
                const containerWidth = imageWrapper.clientWidth;
                let fitScale = containerWidth / currentImage.width;
                fitScale = Math.min(3.0, Math.max(0.05, fitScale));
                document.getElementById('zoomSlider').value = fitScale.toFixed(2);
                document.getElementById('zoomValue').textContent = fitScale.toFixed(2);
                applyZoom();
            }
            
            document.getElementById('inputSize').value = '640';
            analyzeImage();
        }
        
        // ROIåŠŸèƒ½
        function enterRoiMode() { 
            if (!currentImage) return; 
            isRoiMode = true; 
            canvas.style.cursor = 'crosshair'; 
            showToast('æŒ‰ä¸‹/è§¦æ‘¸ç¡®å®šåœ†å¿ƒï¼Œæ‹–åŠ¨è®¾å®šåŠå¾„'); 
        }
        
        function clearRoi() { 
            roiCenter = null; 
            roiRadius = null; 
            roiVisual.style.display = 'none'; 
            document.getElementById('roiIndicator').style.display = 'none'; 
            showToast('ROIå·²æ¸…é™¤'); 
        }
        
        function updateRoiVisual() {
            if (!roiCenter || !roiRadius) { 
                roiVisual.style.display = 'none'; 
                return; 
            }
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            roiVisual.style.left = ((roiCenter.x - roiRadius) * zoom) + 'px';
            roiVisual.style.top = ((roiCenter.y - roiRadius) * zoom) + 'px';
            roiVisual.style.width = (roiRadius * 2 * zoom) + 'px';
            roiVisual.style.height = (roiRadius * 2 * zoom) + 'px';
            roiVisual.style.display = 'block';
            document.getElementById('roiIndicator').style.display = 'inline-flex';
        }
        
        function getImageCoordsFromEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) { 
                clientX = e.touches[0].clientX; 
                clientY = e.touches[0].clientY; 
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else { 
                clientX = e.clientX; 
                clientY = e.clientY; 
            }
            return { 
                x: (clientX - rect.left) / zoom, 
                y: (clientY - rect.top) / zoom 
            };
        }
        
        function handleCanvasMouseDown(e) { 
            if (!isRoiMode) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            roiStart = { x, y }; 
            roiVisual.style.display = 'block'; 
        }
        
        function handleCanvasMouseMove(e) { 
            if (!isRoiMode || !roiStart) return; 
            e.preventDefault(); 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            const zoom = parseFloat(document.getElementById('zoomSlider').value); 
            roiVisual.style.left = ((roiStart.x - radius) * zoom) + 'px'; 
            roiVisual.style.top = ((roiStart.y - radius) * zoom) + 'px'; 
            roiVisual.style.width = (radius * 2 * zoom) + 'px'; 
            roiVisual.style.height = (radius * 2 * zoom) + 'px'; 
        }
        
        function handleCanvasMouseUp(e) { 
            if (!isRoiMode || !roiStart) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            if (radius > 2) { 
                roiCenter = { x: roiStart.x, y: roiStart.y }; 
                roiRadius = radius; 
                updateRoiVisual(); 
                showToast(`ROIå·²è®¾ç½®: åŠå¾„${Math.round(radius)}px`); 
            } else { 
                clearRoi(); 
            } 
            isRoiMode = false; 
            roiStart = null; 
            canvas.style.cursor = 'default'; 
        }
        
        function handleTouchStart(e) { 
            if (!isRoiMode) return;
            e.preventDefault(); 
            const { x, y } = getImageCoordsFromEvent(e); 
            roiStart = { x, y }; 
            roiVisual.style.display = 'block'; 
        }
        
        function handleTouchMove(e) { 
            e.preventDefault(); 
            if (!isRoiMode || !roiStart) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            const zoom = parseFloat(document.getElementById('zoomSlider').value); 
            roiVisual.style.left = ((roiStart.x - radius) * zoom) + 'px'; 
            roiVisual.style.top = ((roiStart.y - radius) * zoom) + 'px'; 
            roiVisual.style.width = (radius * 2 * zoom) + 'px'; 
            roiVisual.style.height = (radius * 2 * zoom) + 'px'; 
        }
        
        function handleTouchEnd(e) { 
            e.preventDefault(); 
            if (!isRoiMode || !roiStart) return; 
            const { x, y } = getImageCoordsFromEvent(e); 
            const radius = Math.sqrt((x - roiStart.x)**2 + (y - roiStart.y)**2); 
            if (radius > 2) { 
                roiCenter = { x: roiStart.x, y: roiStart.y }; 
                roiRadius = radius; 
                updateRoiVisual(); 
                showToast(`ROIå·²è®¾ç½®: åŠå¾„${Math.round(radius)}px`); 
            } else { 
                clearRoi(); 
            } 
            isRoiMode = false; 
            roiStart = null; 
            canvas.style.cursor = 'default'; 
        }
        
        function cancelRoiDraw() { 
            if (isRoiMode) { 
                isRoiMode = false; 
                roiStart = null; 
                canvas.style.cursor = 'default'; 
                roiVisual.style.display = roiCenter ? 'block' : 'none'; 
            } 
        }
        
        // ========== æ ¸å¿ƒï¼šYOLOæ£€æµ‹é€»è¾‘ ==========
        async function analyzeImage() {
            if (!currentImage || !modelLoaded) {
                if (!modelLoaded) showToast('â³ æ¨¡å‹åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...');
                return;
            }
            
            document.getElementById('loadingOverlay').classList.add('active');
            
            // ä½¿ç”¨setTimeoutè®©UIæ›´æ–°
            setTimeout(async () => {
                try {
                    const confThreshold = parseFloat(document.getElementById('confThreshold').value);
                    const iouThreshold = parseFloat(document.getElementById('iouThreshold').value);
                    const inputSize = parseInt(document.getElementById('inputSize').value);
                    const contrast = parseFloat(document.getElementById('contrast').value);
                    const brightness = parseInt(document.getElementById('brightness').value);
                    const minRadiusFilter = parseInt(document.getElementById('minRadiusFilter').value);
                    const maxRadiusFilter = parseInt(document.getElementById('maxRadiusFilter').value);
                    
                    // 1. é¢„å¤„ç†å›¾åƒ
                    const processedTensor = await preprocessImage(currentImage, inputSize, contrast, brightness);
                    
                    // 2. è¿è¡ŒYOLOæ¨ç†
                    const feeds = { images: processedTensor };
                    const results = await session.run(feeds);
                    
                    // 3. è§£æYOLOè¾“å‡º
                    // YOLOv8è¾“å‡ºæ ¼å¼: [batch, 84, 8400] æˆ– [batch, 5 + num_classes, num_boxes]
                    // å…¶ä¸­84 = 4(box) + 80(classes)ï¼Œå¯¹äºå•ç±»èŒè½æ£€æµ‹åº”è¯¥æ˜¯5 = 4(box) + 1(class)
                    const output = results.output0 || results[Object.keys(results)[0]];
                    const detections = parseYOLOOutput(output, confThreshold, iouThreshold, inputSize);
                    
                    // 4. åæ ‡æ˜ å°„å›åŸå§‹å›¾åƒå°ºå¯¸
                    const scaleX = currentImage.width / inputSize;
                    const scaleY = currentImage.height / inputSize;
                    
                    let detected = detections.map((det, idx) => {
                        // è®¡ç®—ç­‰æ•ˆåŠå¾„ï¼ˆä»è¾¹ç•Œæ¡†é¢ç§¯æ¨ç®—ï¼‰
                        const boxWidth = det.x2 - det.x1;
                        const boxHeight = det.y2 - det.y1;
                        const radius = Math.sqrt(boxWidth * boxHeight) / 2; // ç­‰æ•ˆåœ†åŠå¾„
                        
                        return {
                            id: idx,
                            x: (det.x1 + det.x2) / 2, // ä¸­å¿ƒç‚¹x
                            y: (det.y1 + det.y2) / 2, // ä¸­å¿ƒç‚¹y
                            radius: radius,
                            confidence: det.confidence,
                            box: [det.x1, det.y1, det.x2, det.y2], // ä¿ç•™è¾¹ç•Œæ¡†ä¿¡æ¯
                            manual: false
                        };
                    });
                    
                    // 5. åŠå¾„è¿‡æ»¤
                    detected = detected.filter(c => c.radius >= minRadiusFilter && c.radius <= maxRadiusFilter);
                    
                    // 6. ROIè¿‡æ»¤
                    if (roiCenter && roiRadius) {
                        detected = detected.filter(c => {
                            const dx = c.x - roiCenter.x;
                            const dy = c.y - roiCenter.y;
                            return (dx*dx + dy*dy) <= (roiRadius * roiRadius);
                        });
                    }
                    
                    colonies = detected;
                    
                    // æ¸…ç†tensorå†…å­˜
                    processedTensor.dispose();
                    
                    renderMarkers();
                    updateStats();
                    showToast(`âœ… YOLOæ£€æµ‹åˆ° ${colonies.length} ä¸ªèŒè½`);
                    
                } catch (err) {
                    console.error('Analysis error:', err);
                    showToast('âŒ åˆ†æå¤±è´¥: ' + err.message);
                }
                
                document.getElementById('loadingOverlay').classList.remove('active');
            }, 100);
        }
        
        // YOLOå›¾åƒé¢„å¤„ç†
        async function preprocessImage(img, inputSize, contrast, brightness) {
            // åˆ›å»ºä¸´æ—¶canvasè¿›è¡Œé¢„å¤„ç†
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = inputSize;
            tempCanvas.height = inputSize;
            const tCtx = tempCanvas.getContext('2d');
            
            // è®¡ç®—letterboxå¡«å……ï¼ˆä¿æŒå®½é«˜æ¯”ï¼‰
            const scale = Math.min(inputSize / img.width, inputSize / img.height);
            const newWidth = img.width * scale;
            const newHeight = img.height * scale;
            const padX = (inputSize - newWidth) / 2;
            const padY = (inputSize - newHeight) / 2;
            
            // å¡«å……ç°è‰²èƒŒæ™¯ï¼ˆYOLOæ ‡å‡†é¢„å¤„ç†ï¼‰
            tCtx.fillStyle = '#808080';
            tCtx.fillRect(0, 0, inputSize, inputSize);
            
            // åº”ç”¨å¯¹æ¯”åº¦å’Œäº®åº¦è°ƒæ•´
            tCtx.filter = `contrast(${contrast}) brightness(${100 + brightness}%)`;
            tCtx.drawImage(img, padX, padY, newWidth, newHeight);
            tCtx.filter = 'none';
            
            // è·å–å›¾åƒæ•°æ®
            const imageData = tCtx.getImageData(0, 0, inputSize, inputSize);
            const data = imageData.data;
            
            // è½¬æ¢ä¸ºRGB float32æ•°ç»„å¹¶å½’ä¸€åŒ–ï¼ˆ0-1ï¼‰
            const red = [], green = [], blue = [];
            for (let i = 0; i < data.length; i += 4) {
                red.push(data[i] / 255);
                green.push(data[i + 1] / 255);
                blue.push(data[i + 2] / 255);
            }
            
            // åˆ›å»ºONNX tensor [1, 3, height, width]
            const inputData = new Float32Array(red.concat(green).concat(blue));
            const tensor = new ort.Tensor('float32', inputData, [1, 3, inputSize, inputSize]);
            
            return tensor;
        }
        
        // è§£æYOLOè¾“å‡ºï¼ˆæ”¯æŒYOLOv8æ ¼å¼ï¼‰
        function parseYOLOOutput(output, confThreshold, iouThreshold, inputSize) {
            const data = output.data;
            const dims = output.dims; // é€šå¸¸æ˜¯ [1, 84, 8400] æˆ– [1, 5, 8400]
            
            const numClasses = dims[1] - 4; // ç±»åˆ«æ•°
            const numBoxes = dims[2]; // è¾¹ç•Œæ¡†æ•°é‡
            
            let boxes = [];
            
            // éå†æ‰€æœ‰è¾¹ç•Œæ¡†
            for (let i = 0; i < numBoxes; i++) {
                // æå–è¾¹ç•Œæ¡†åæ ‡ (x_center, y_center, width, height)
                const cx = data[i];
                const cy = data[numBoxes + i];
                const w = data[2 * numBoxes + i];
                const h = data[3 * numBoxes + i];
                
                // æå–ç±»åˆ«ç½®ä¿¡åº¦ï¼ˆå‡è®¾å•ç±»èŒè½æ£€æµ‹ï¼Œå–æœ€å¤§ç½®ä¿¡åº¦ï¼‰
                let maxConf = 0;
                let classId = 0;
                
                for (let c = 0; c < numClasses; c++) {
                    const conf = data[(4 + c) * numBoxes + i];
                    if (conf > maxConf) {
                        maxConf = conf;
                        classId = c;
                    }
                }
                
                // è¿‡æ»¤ä½ç½®ä¿¡åº¦
                if (maxConf > confThreshold) {
                    // è½¬æ¢ä¸ºå·¦ä¸Šè§’å’Œå³ä¸‹è§’åæ ‡
                    const x1 = (cx - w / 2); // * inputSize; // ä¿æŒå½’ä¸€åŒ–åæ ‡
                    const y1 = (cy - h / 2); // * inputSize;
                    const x2 = (cx + w / 2); // * inputSize;
                    const y2 = (cy + h / 2); // * inputSize;
                    
                    boxes.push({
                        x1: x1 * inputSize,
                        y1: y1 * inputSize,
                        x2: x2 * inputSize,
                        y2: y2 * inputSize,
                        confidence: maxConf,
                        classId: classId
                    });
                }
            }
            
            // åº”ç”¨NMSï¼ˆéæå¤§å€¼æŠ‘åˆ¶ï¼‰
            return applyNMS(boxes, iouThreshold);
        }
        
        // NMSç®—æ³•
        function applyNMS(boxes, iouThreshold) {
            if (boxes.length === 0) return [];
            
            // æŒ‰ç½®ä¿¡åº¦æ’åº
            boxes.sort((a, b) => b.confidence - a.confidence);
            
            const picked = [];
            const suppressed = new Array(boxes.length).fill(false);
            
            for (let i = 0; i < boxes.length; i++) {
                if (suppressed[i]) continue;
                
                picked.push(boxes[i]);
                
                for (let j = i + 1; j < boxes.length; j++) {
                    if (suppressed[j]) continue;
                    
                    const iou = calculateIoU(boxes[i], boxes[j]);
                    if (iou > iouThreshold) {
                        suppressed[j] = true;
                    }
                }
            }
            
            return picked;
        }
        
        // è®¡ç®—IoUï¼ˆäº¤å¹¶æ¯”ï¼‰
        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x1, box2.x1);
            const y1 = Math.max(box1.y1, box2.y1);
            const x2 = Math.min(box1.x2, box2.x2);
            const y2 = Math.min(box1.y2, box2.y2);
            
            const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
            const area1 = (box1.x2 - box1.x1) * (box1.y2 - box1.y1);
            const area2 = (box2.x2 - box2.x1) * (box2.y2 - box2.y1);
            const union = area1 + area2 - intersection;
            
            return union > 0 ? intersection / union : 0;
        }
        
        function renderMarkers() {
            overlayLayer.innerHTML = '';
            overlayLayer.appendChild(roiVisual);
            
            const zoom = parseFloat(document.getElementById('zoomSlider').value);
            
            colonies.forEach((colony, idx) => {
                const marker = document.createElement('div');
                marker.className = `colony-marker ${colony.manual ? 'manual' : ''}`;
                marker.style.left = (colony.x * zoom) + 'px';
                marker.style.top = (colony.y * zoom) + 'px';
                
                if (showCircles) {
                    const circle = document.createElement('div');
                    circle.className = 'marker-circle';
                    circle.style.width = (colony.radius * zoom * 2) + 'px';
                    circle.style.height = (colony.radius * zoom * 2) + 'px';
                    marker.appendChild(circle);
                }
                
                const center = document.createElement('div');
                center.className = 'marker-center';
                marker.appendChild(center);
                
                const tooltip = document.createElement('div');
                tooltip.className = 'marker-tooltip';
                tooltip.textContent = `#${idx + 1} | r=${Math.round(colony.radius)} | ${(colony.confidence * 100).toFixed(0)}%`;
                marker.appendChild(tooltip);
                
                marker.onclick = (e) => { 
                    e.stopPropagation(); 
                    removeColony(idx); 
                };
                
                overlayLayer.appendChild(marker);
            });
            
            if (roiCenter && roiRadius) updateRoiVisual();
        }
        
        function updateStats() {
            const auto = colonies.filter(c => !c.manual).length;
            const manual = colonies.filter(c => c.manual).length;
            const avgRadius = colonies.length > 0 ? 
                (colonies.reduce((sum, c) => sum + c.radius, 0) / colonies.length).toFixed(1) : 0;
            
            document.getElementById('statTotal').textContent = colonies.length;
            document.getElementById('statAuto').textContent = auto;
            document.getElementById('statManual').textContent = manual;
            document.getElementById('statAvgRadius').textContent = avgRadius;
        }
        
        function removeColony(index) { 
            colonies.splice(index, 1); 
            colonies.forEach((c, idx) => c.id = idx); 
            renderMarkers(); 
            updateStats(); 
            showToast('ğŸ—‘ï¸ å·²åˆ é™¤'); 
        }
        
        function toggleAddMode() {
            isAddMode = !isAddMode;
            const btn = document.getElementById('addModeBtn');
            if (isAddMode) { 
                btn.style.background = 'var(--success)'; 
                btn.innerHTML = '<span>âœ“</span><span>å®Œæˆæ·»åŠ </span>'; 
                canvas.style.cursor = 'crosshair'; 
            } else { 
                btn.style.background = ''; 
                btn.innerHTML = '<span>â•</span><span>æ‰‹åŠ¨æ·»åŠ </span>'; 
                canvas.style.cursor = 'default'; 
            }
        }
        
        function toggleCircles() { 
            showCircles = !showCircles; 
            renderMarkers(); 
            showToast(showCircles ? 'â­• æ˜¾ç¤ºåœ†åœˆ' : 'â­• éšè—åœ†åœˆ'); 
        }
        
        function handleCanvasClick(e) {
            if (!isAddMode) return;
            const { x, y } = getImageCoordsFromEvent(e);
            const avgRadius = colonies.length > 0 ? 
                colonies.reduce((sum, c) => sum + c.radius, 0) / colonies.length : 10;
            
            colonies.push({ 
                id: colonies.length, 
                x: x, 
                y: y, 
                radius: avgRadius, 
                confidence: 1.0, 
                manual: true 
            });
            
            renderMarkers(); 
            updateStats(); 
            showToast('âœ… å·²æ·»åŠ ');
        }
        
        function clearAll() { 
            if (confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰æ ‡è®°ï¼Ÿ')) { 
                colonies = []; 
                renderMarkers(); 
                updateStats(); 
                showToast('ğŸ—‘ï¸ å·²æ¸…ç©º'); 
            } 
        }
        
        function resetApp() {
            currentImage = null; 
            colonies = []; 
            isAddMode = false; 
            clearRoi();
            uploadCard.style.display = 'block'; 
            viewer.classList.remove('active');
            overlayLayer.innerHTML = ''; 
            overlayLayer.appendChild(roiVisual);
            canvas.style.cursor = 'default';
        }
        
        function exportImage() {
            if (!currentImage) return;
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = currentImage.width; 
            exportCanvas.height = currentImage.height;
            const eCtx = exportCanvas.getContext('2d');
            
            eCtx.drawImage(currentImage, 0, 0);
            
            colonies.forEach(c => {
                // ç»˜åˆ¶åœ†åœˆ
                eCtx.beginPath(); 
                eCtx.arc(c.x, c.y, c.radius, 0, 2 * Math.PI);
                eCtx.strokeStyle = c.manual ? 'gold' : '#ff4757'; 
                eCtx.lineWidth = 2; 
                eCtx.stroke();
                
                // ç»˜åˆ¶ä¸­å¿ƒç‚¹
                eCtx.beginPath(); 
                eCtx.arc(c.x, c.y, 3, 0, 2 * Math.PI);
                eCtx.fillStyle = c.manual ? 'gold' : '#00ff88'; 
                eCtx.fill();
                
                // ç»˜åˆ¶ç¼–å·
                eCtx.fillStyle = c.manual ? 'gold' : '#00ff88';
                eCtx.font = '12px Arial';
                eCtx.fillText(`#${c.id + 1}`, c.x + c.radius + 5, c.y);
            });
            
            const link = document.createElement('a'); 
            link.download = `colonies_yolo_${Date.now()}.png`; 
            link.href = exportCanvas.toDataURL('image/png'); 
            link.click();
            
            showToast('ğŸ“¸ å›¾ç‰‡å·²å¯¼å‡º');
        }
        
        function showToast(msg) { 
            const toast = document.getElementById('toast'); 
            toast.textContent = msg; 
            toast.classList.add('show'); 
            setTimeout(() => toast.classList.remove('show'), 3000); 
        }
        
        window.addEventListener('resize', () => { 
            if (currentImage && viewer.classList.contains('active')) { 
                const containerWidth = imageWrapper.clientWidth; 
                let fitScale = containerWidth / currentImage.width; 
                fitScale = Math.min(3.0, Math.max(0.05, fitScale)); 
                document.getElementById('zoomSlider').value = fitScale.toFixed(2); 
                document.getElementById('zoomValue').textContent = fitScale.toFixed(2); 
                applyZoom(); 
            } 
        });
        
        // Service Worker
        if ('serviceWorker' in navigator) { 
            const swCode = `self.addEventListener('install',e=>self.skipWaiting()); self.addEventListener('activate',e=>e.waitUntil(clients.claim())); self.addEventListener('fetch',e=>e.respondWith(fetch(e.request)));`; 
            const blob = new Blob([swCode], { type: 'application/javascript' }); 
            navigator.serviceWorker.register(URL.createObjectURL(blob)).catch(()=>{}); 
        }
    </script>
</body>
</html>
