<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>èŒè½è®¡æ•°åŠ©æ‰‹ï¼ˆä¿®å¤ç‰ˆï¼‰</title>
  <style>
    :root {
      --p: #1d4ed8; --s: #10b981; --w: #f59e0b; --d: #ef4444;
      --bg: #f8fafc; --card: #fff; --text: #1e293b;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family: -apple-system, sans-serif; color: var(--text); background: var(--bg); }
    .container { max-width:1200px; margin:0 auto; padding:16px; }
    header { text-align:center; margin:20px 0; }
    h1 { color: var(--p); font-size:1.8rem; }
    p.subtitle { color:#64748b; margin:8px 0; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:20px; }
    @media(max-width:768px){ .grid{grid-template-columns:1fr;} }
    .card { background:var(--card); border-radius:12px; padding:20px; box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    h2 { color:var(--p); margin:0 0 16px; padding-bottom:8px; border-bottom:2px solid var(--p); }
    #camera { height:300px; display:flex; align-items:center; justify-content:center; background:#f1f5f9; border:2px dashed #cbd5e1; border-radius:8px; font-style:italic; color:#94a3b8; }
    button { padding:10px 16px; border:none; border-radius:6px; background:var(--p); color:white; cursor:pointer; font-weight:600; }
    button:hover { background:#1e40af; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    .result-row { display:flex; justify-content:space-between; padding:10px 0; border-bottom:1px #e2e8f0 solid; }
    .note { font-size:0.9rem; padding:12px; background:#f0f9ff; border-radius:6px; margin-top:12px; }
    canvas { width:100%; height:auto; border-radius:6px; border:1px #cbd5e1 solid; display:block; background:#fff; }
    #status { margin-top:12px; font-weight:500; }
    .good { color:var(--s); }
    .warn { color:var(--w); }
    .bad { color:var(--d); }
    .loading { color:var(--p); text-align:center; padding:20px; }
  </style>
</head>
<body>
<div class="container">
  <header>
    <h1>ğŸ¦  èŒè½è®¡æ•°åŠ©æ‰‹ï¼ˆä¿®å¤ç‰ˆï¼‰</h1>
    <p class="subtitle">âœ… ä¸­å¿ƒæ ‡è®°è“ç‚¹ï½œâœ… é€‚é…ä»»æ„å¹³æ¿ï½œâœ… ç‚¹å‡»å¿…å“åº”</p>
  </header>

  <div class="grid">
    <!-- è¾“å…¥åŒº -->
    <div class="card">
      <h2>æ‹æ‘„æˆ–ä¸Šä¼ å›¾åƒ</h2>
      <div id="camera">ğŸ“· ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯åŠ¨ç›¸æœºæˆ–ä¸Šä¼ å›¾åƒ</div>
      <div style="margin-top:16px;display:flex;gap:12px;">
        <button id="btn-capture">ğŸ“¸ æ‹ç…§</button>
        <button id="btn-upload">ğŸ“¤ ä¸Šä¼ </button>
      </div>
      <div id="status" class="loading">å‡†å¤‡å°±ç»ª</div>
    </div>

    <!-- ç»“æœåŒº -->
    <div class="card">
      <h2>è®¡æ•°ç»“æœ</h2>
      <div style="background:#f0f9ff;padding:16px;border-radius:8px;">
        <div class="result-row">
          <span>æ£€æµ‹èŒè½æ•°ï¼š</span>
          <span id="count" class="good">0</span>
        </div>
        <div class="result-row">
          <span>ç½®ä¿¡åº¦ï¼š</span>
          <span id="conf">å¾…å¤„ç†</span>
        </div>
        <div class="result-row">
          <span>å¤„ç†çŠ¶æ€ï¼š</span>
          <span id="status-text">ç©ºé—²</span>
        </div>
      </div>
      <div class="note" id="note">è¯·ä¿¯æ‹å¹³æ¿ï¼ŒèƒŒæ™¯å‡åŒ€ï¼Œé¿å…é˜´å½±å’Œåå…‰</div>
      
      <h3 style="margin:20px 0 10px;">èŒè½å®šä½å¯è§†åŒ–</h3>
      <canvas id="canvas-out" height="300"></canvas>
    </div>
  </div>

  <footer style="text-align:center;margin-top:40px;color:#64748b;font-size:0.85rem;">
    Â© 2026 èŒè½è®¡æ•°åŠ©æ‰‹ | ä¿®å¤ï¼šç‚¹å‡»å¿…å“åº”
  </footer>
</div>

<script>
let cvLoaded = false;
let cvRetryCount = 0;
const MAX_RETRY = 3;

function loadOpenCV() {
  return new Promise((resolve, reject) => {
    if (typeof cv !== 'undefined' && typeof cv.Mat === 'function') {
      resolve();
      return;
    }

    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/opencv.js@4.9.0/dist/opencv.min.js';
    script.onload = () => {
      const check = setInterval(() => {
        if (typeof cv !== 'undefined' && typeof cv.Mat === 'function') {
          clearInterval(check);
          cvLoaded = true;
          console.log('âœ… OpenCV.js åŠ è½½æˆåŠŸ');
          resolve();
        }
      }, 200);

      setTimeout(() => {
        clearInterval(check);
        if (!cvLoaded) {
          console.warn('âš ï¸ OpenCV åˆå§‹åŒ–è¶…æ—¶ï¼Œå¯ç”¨çº¯JSå…œåº•');
          cvLoaded = false;
          resolve();
        }
      }, 8000);
    };
    script.onerror = () => {
      cvRetryCount++;
      if (cvRetryCount < MAX_RETRY) {
        console.log(`ğŸ”„ ç¬¬ ${cvRetryCount} æ¬¡é‡è¯•åŠ è½½ OpenCV...`);
        setTimeout(loadOpenCV, 2000);
      } else {
        console.error('âŒ OpenCV.js åŠ è½½å¤±è´¥ï¼Œå¯ç”¨çº¯JSæ¨¡å¼');
        cvLoaded = false;
        resolve();
      }
    };
    document.head.appendChild(script);
  });
}

// âœ…ã€å…³é”®ä¿®å¤ã€‘ç«‹å³ç»‘å®šæŒ‰é’®äº‹ä»¶ï¼ˆä¸ç­‰å¾…OpenCVï¼‰
function bindButtons() {
  const btnCapture = document.getElementById('btn-capture');
  const btnUpload = document.getElementById('btn-upload');
  const cameraDiv = document.getElementById('camera');
  const statusEl = document.getElementById('status');
  const statusTextEl = document.getElementById('status-text');
  const noteEl = document.getElementById('note');
  const countEl = document.getElementById('count');
  const confEl = document.getElementById('conf');
  const canvasOut = document.getElementById('canvas-out');
  const ctx = canvasOut.getContext('2d');

  let videoStream = null;
  let videoElement = null;

  async function initCamera() {
    if (videoStream) return;
    try {
      const constraints = {
        video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
      };
      videoStream = await navigator.mediaDevices.getUserMedia(constraints);
      videoElement = document.createElement('video');
      videoElement.srcObject = videoStream;
      videoElement.autoplay = true;
      videoElement.playsInline = true;
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.objectFit = 'cover';
      cameraDiv.innerHTML = '';
      cameraDiv.appendChild(videoElement);
      statusEl.textContent = 'âœ… ç›¸æœºå·²å¯åŠ¨ï¼Œè¯·å¯¹å‡†å¹³æ¿';
      statusEl.className = 'loading good';
      statusTextEl.textContent = 'ç›¸æœºå°±ç»ª';
    } catch (err) {
      console.error('ç›¸æœºå¯åŠ¨å¤±è´¥:', err);
      statusEl.textContent = `âŒ ç›¸æœºé”™è¯¯: ${err.message}`;
      statusEl.className = 'loading bad';
      statusTextEl.textContent = 'ç›¸æœºè®¿é—®å¤±è´¥';
      noteEl.textContent = `è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™ï¼Œæˆ–ä½¿ç”¨â€œä¸Šä¼ â€åŠŸèƒ½`;
    }
  }

  // æ‹ç…§
  btnCapture.addEventListener('click', async () => {
    statusEl.textContent = 'ğŸ“· æ­£åœ¨æ•è·å›¾åƒ...';
    statusEl.className = 'loading';
    statusTextEl.textContent = 'æ•è·ä¸­';

    try {
      if (!videoElement) {
        await initCamera();
        if (!videoElement) throw new Error('ç›¸æœºæœªåˆå§‹åŒ–');
      }
      const canvas = document.createElement('canvas');
      canvas.width = videoElement.videoWidth || 640;
      canvas.height = videoElement.videoHeight || 480;
      const ctxTmp = canvas.getContext('2d');
      ctxTmp.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));
      await processImage(blob);
    } catch (err) {
      statusEl.textContent = `âŒ æ‹ç…§å¤±è´¥: ${err.message}`;
      statusEl.className = 'loading bad';
      statusTextEl.textContent = 'æ‹ç…§å¼‚å¸¸';
      console.error('æ‹ç…§é”™è¯¯:', err);
    }
  });

  // ä¸Šä¼ 
  btnUpload.addEventListener('click', () => {
    statusEl.textContent = 'ğŸ“¤ æ­£åœ¨æ‰“å¼€æ–‡ä»¶é€‰æ‹©å™¨...';
    statusEl.className = 'loading';
    statusTextEl.textContent = 'ç­‰å¾…ä¸Šä¼ ';

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async (e) => {
      if (e.target.files[0]) {
        try {
          await processImage(e.target.files[0]);
        } catch (err) {
          statusEl.textContent = `âŒ ä¸Šä¼ å¤„ç†å¤±è´¥: ${err.message}`;
          statusEl.className = 'loading bad';
          statusTextEl.textContent = 'å¤„ç†å¼‚å¸¸';
          console.error('ä¸Šä¼ é”™è¯¯:', err);
        }
      }
    };
    input.click();
  });
}

// ===== ä¸»åº”ç”¨é€»è¾‘ =====
document.addEventListener('DOMContentLoaded', async () => {
  // âœ… å…³é”®ï¼šç«‹å³ç»‘å®šæŒ‰é’®ï¼Œä¸ç­‰å¾…OpenCV
  bindButtons();

  // åç»­åŠ è½½OpenCVï¼ˆä»…ç”¨äºæå‡ç²¾åº¦ï¼Œä¸å½±å“æŒ‰é’®å“åº”ï¼‰
  statusEl.textContent = 'â³ åŠ è½½å›¾åƒå¤„ç†å¼•æ“...';
  statusTextEl.textContent = 'åˆå§‹åŒ–ä¸­';
  loadOpenCV().then(() => {
    statusEl.textContent = 'âœ… å¼•æ“å°±ç»ªï¼ç‚¹å‡»â€œæ‹ç…§â€æˆ–â€œä¸Šä¼ â€å¼€å§‹';
    statusEl.className = 'loading good';
    statusTextEl.textContent = 'ç©ºé—²';
  }).catch(err => {
    console.warn('OpenCV åŠ è½½å¤±è´¥ï¼Œå·²å¯ç”¨çº¯JSæ¨¡å¼');
    statusEl.textContent = 'âš ï¸ é™çº§æ¨¡å¼ï¼šçº¯JSè®¡æ•°ï¼ˆåŠŸèƒ½å®Œæ•´ï¼‰';
    statusEl.className = 'loading warn';
    statusTextEl.textContent = 'çº¯JSæ¨¡å¼';
  });

  // ========== åŸæœ‰ processImage / countWithOpenCV / countWithPureJS ä¿æŒä¸å˜ ==========
  async function processImage(file) {
    try {
      const img = new Image();
      img.src = URL.createObjectURL(file);
      await new Promise(r => img.onload = r);

      canvasOut.width = img.width;
      canvasOut.height = img.height;
      ctx.clearRect(0, 0, canvasOut.width, canvasOut.height);
      ctx.drawImage(img, 0, 0);

      let colonyCount = 0;
      let centers = [];

      if (cvLoaded && typeof cv !== 'undefined') {
        ({ count: colonyCount, centers }) = await countWithOpenCV(img);
      } else {
        ({ count: colonyCount, centers }) = countWithPureJS(img);
      }

      countEl.textContent = colonyCount;
      confEl.textContent = getConfidenceLabel(colonyCount, centers.length);
      statusEl.textContent = `âœ… è®¡æ•°å®Œæˆï¼š${colonyCount} ä¸ªèŒè½`;
      statusEl.className = 'loading good';
      statusTextEl.textContent = 'è®¡æ•°å®Œæˆ';
      noteEl.textContent = colonyCount > 0 
        ? 'âœ… èŒè½å·²æ ‡è®°ï¼ˆè“è‰²åœ†ç‚¹ä¸ºè¯†åˆ«ä¸­å¿ƒï¼‰'
        : 'âš ï¸ æœªæ£€æµ‹åˆ°èŒè½ï¼Œè¯·æ£€æŸ¥å›¾åƒè´¨é‡æˆ–é‡æ‹';

      ctx.fillStyle = 'rgba(30, 144, 255, 0.9)';
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.lineWidth = 1;
      for (const [x, y] of centers) {
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }

    } catch (err) {
      console.error('å¤„ç†å¤±è´¥:', err);
      countEl.textContent = 'é”™è¯¯';
      confEl.textContent = 'å¤„ç†å¤±è´¥';
      statusEl.textContent = `âŒ å¼‚å¸¸: ${err.message}`;
      statusEl.className = 'loading bad';
      statusTextEl.textContent = 'å¤„ç†å¼‚å¸¸';
      noteEl.textContent = 'è¯·é‡è¯•æˆ–æ¢ä¸€å¼ æ¸…æ™°å›¾åƒ';
    }
  }

  function getConfidenceLabel(count, centerCount) {
    if (count === 0) return 'æ— èŒè½';
    if (count < 5) return 'ä½ï¼ˆæ ·æœ¬ç¨€ç–ï¼‰';
    if (count <= 50) return 'é«˜ï¼ˆåˆ†å¸ƒåˆç†ï¼‰';
    if (count <= 200) return 'é«˜ï¼ˆå¯†é›†ä½†å¯åˆ†ï¼‰';
    return 'ä¸­ï¼ˆæå¯†é›†ï¼Œé»è¿é£é™©â†‘ï¼‰';
  }

  async function countWithOpenCV(img) {
    return new Promise(resolve => {
      setTimeout(() => {
        try {
          const src = cv.matFromImageData(img);
          const gray = new cv.Mat();
          const blurred = new cv.Mat();
          const thresh = new cv.Mat();
          const contours = new cv.MatVector();

          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
          cv.threshold(blurred, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

          cv.findContours(thresh, contours, new cv.Mat(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

          const centers = [];
          let validCount = 0;
          const minArea = 35;
          const maxArea = 800;

          for (let i = 0; i < contours.size(); i++) {
            const cnt = contours.get(i);
            const area = cv.contourArea(cnt);
            if (area < minArea || area > maxArea) continue;

            const moments = cv.moments(cnt);
            const cx = moments.m10 / moments.m00;
            const cy = moments.m01 / moments.m00;
            centers.push([cx, cy]);
            validCount++;
          }

          src.delete(); gray.delete(); blurred.delete(); thresh.delete(); contours.delete();
          resolve({ count: validCount, centers });

        } catch (e) {
          console.warn('OpenCV è®¡æ•°å‡ºé”™ï¼Œé™çº§', e);
          resolve(countWithPureJS(img));
        }
      }, 600);
    });
  }

  function countWithPureJS(img) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx2 = canvas.getContext('2d');
    ctx2.drawImage(img, 0, 0);

    const imageData = ctx2.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const w = canvas.width, h = canvas.height;
    const visited = new Uint8Array(w * h);
    const centers = [];
    let count = 0;

    const pixels = [];
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      const gray = 0.299*r + 0.587*g + 0.114*b;
      pixels.push(gray);
    }

    const sorted = [...pixels].sort((a,b)=>a-b);
    const thresh = sorted[Math.floor(sorted.length * 0.6)];

    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const idx = y * w + x;
        if (pixels[idx] > thresh && visited[idx] === 0) {
          const stack = [[x, y]];
          let sumX = 0, sumY = 0, area = 0;
          while (stack.length) {
            const [cx, cy] = stack.pop();
            const i = cy * w + cx;
            if (i < 0 || i >= w*h || visited[i] || pixels[i] <= thresh) continue;
            visited[i] = 1;
            sumX += cx;
            sumY += cy;
            area++;
            stack.push([cx+1,cy], [cx-1,cy], [cx,cy+1], [cx,cy-1]);
          }
          if (area >= 35 && area <= 800) {
            centers.push([sumX / area, sumY / area]);
            count++;
          }
        }
      }
    }

    return { count, centers };
  }
});
</script>
</body>
</html>
