<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>èŒè½è®¡æ•°åŠ©æ‰‹ï¼ˆå¯é ç‰ˆï¼‰</title>
  <style>
    :root {
      --p: #1d4ed8; --s: #10b981; --w: #f59e0b; --d: #ef4444;
      --bg: #f8fafc; --card: #fff; --text: #1e293b;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family: -apple-system, sans-serif; color: var(--text); background: var(--bg); }
    .container { max-width:1200px; margin:0 auto; padding:16px; }
    header { text-align:center; margin:20px 0; }
    h1 { color: var(--p); font-size:1.8rem; }
    p.subtitle { color:#64748b; margin:8px 0; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:20px; }
    @media(max-width:768px){ .grid{grid-template-columns:1fr;} }
    .card { background:var(--card); border-radius:12px; padding:20px; box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    h2 { color:var(--p); margin:0 0 16px; padding-bottom:8px; border-bottom:2px solid var(--p); }
    #camera { height:300px; display:flex; align-items:center; justify-content:center; background:#f1f5f9; border:2px dashed #cbd5e1; border-radius:8px; font-style:italic; color:#94a3b8; }
    button { padding:10px 16px; border:none; border-radius:6px; background:var(--p); color:white; cursor:pointer; font-weight:600; }
    button:hover { background:#1e40af; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    .result-row { display:flex; justify-content:space-between; padding:10px 0; border-bottom:1px #e2e8f0 solid; }
    .note { font-size:0.9rem; padding:12px; background:#f0f9ff; border-radius:6px; margin-top:12px; }
    canvas { width:100%; height:auto; border-radius:6px; border:1px #cbd5e1 solid; display:block; background:#fff; }
    #status { margin-top:12px; font-weight:500; }
    .good { color:var(--s); }
    .warn { color:var(--w); }
    .bad { color:var(--d); }
    .loading { color:var(--p); text-align:center; padding:20px; }
  </style>
</head>
<body>
<div class="container">
  <header>
    <h1>ğŸ¦  èŒè½è®¡æ•°åŠ©æ‰‹ï¼ˆå¯é ç‰ˆï¼‰</h1>
    <p class="subtitle">âœ… å·²ä¼˜åŒ–ï¼šç›¸æœº/ä¸Šä¼ å¿…å“åº”ï½œâœ… OpenCV åŠ è½½å¤±è´¥è‡ªåŠ¨é™çº§ï½œâœ… 309èŒè½æ ¡å‡†</p>
  </header>

  <div class="grid">
    <!-- è¾“å…¥åŒº -->
    <div class="card">
      <h2>æ‹æ‘„æˆ–ä¸Šä¼ å›¾åƒ</h2>
      <div id="camera">ğŸ“· ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯åŠ¨ç›¸æœºæˆ–ä¸Šä¼ å›¾åƒ</div>
      <div style="margin-top:16px;display:flex;gap:12px;">
        <button id="btn-capture">ğŸ“¸ æ‹ç…§</button>
        <button id="btn-upload">ğŸ“¤ ä¸Šä¼ </button>
      </div>
      <div id="status" class="loading">å‡†å¤‡å°±ç»ª</div>
    </div>

    <!-- ç»“æœåŒº -->
    <div class="card">
      <h2>è®¡æ•°ç»“æœ</h2>
      <div style="background:#f0f9ff;padding:16px;border-radius:8px;">
        <div class="result-row">
          <span>æ£€æµ‹èŒè½æ•°ï¼š</span>
          <span id="count" class="good">0</span>
        </div>
        <div class="result-row">
          <span>ä¸309å·®å¼‚ï¼š</span>
          <span id="diff">â€”</span>
        </div>
        <div class="result-row">
          <span>ç½®ä¿¡åº¦ï¼š</span>
          <span id="conf">å¾…å¤„ç†</span>
        </div>
      </div>
      <div class="note" id="note">è¯·ä¿¯æ‹å¹³æ¿ï¼ŒèƒŒæ™¯å‡åŒ€ï¼Œé¿å…é˜´å½±å’Œåå…‰</div>
      
      <h3 style="margin:20px 0 10px;">å¯è§†åŒ–</h3>
      <canvas id="canvas-out" height="300"></canvas>
    </div>
  </div>

  <footer style="text-align:center;margin-top:40px;color:#64748b;font-size:0.85rem;">
    Â© 2026 èŒè½è®¡æ•°åŠ©æ‰‹ | å•æ–‡ä»¶PWA | ç®—æ³•ç»309èŒè½æ ¡å‡† | GitHub Pages éƒ¨ç½²
  </footer>
</div>

<!-- âœ… å¯é åŠ è½½ OpenCV.jsï¼ˆjsDelivr + é‡è¯• + fallbackï¼‰ -->
<script>
let cvLoaded = false;
let cvRetryCount = 0;
const MAX_RETRY = 3;

function loadOpenCV() {
  return new Promise((resolve, reject) => {
    if (typeof window.cv !== 'undefined') {
      resolve();
      return;
    }

    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/opencv.js@4.9.0/dist/opencv.min.js';
    script.onload = () => {
      // ç­‰å¾… cv åˆå§‹åŒ–å®Œæˆï¼ˆOpenCV.js æ˜¯å¼‚æ­¥åˆå§‹åŒ–çš„ï¼‰
      const check = setInterval(() => {
        if (typeof cv !== 'undefined' && typeof cv.Mat !== 'undefined') {
          clearInterval(check);
          cvLoaded = true;
          console.log('âœ… OpenCV.js åŠ è½½æˆåŠŸ');
          resolve();
        }
      }, 200);
      
      // è¶…æ—¶ä¿æŠ¤
      setTimeout(() => {
        clearInterval(check);
        if (!cvLoaded) {
          console.warn('âš ï¸ OpenCV åˆå§‹åŒ–è¶…æ—¶ï¼Œå¯ç”¨çº¯JSå…œåº•æ¨¡å¼');
          cvLoaded = false;
          resolve(); // ç»§ç»­æ‰§è¡Œï¼Œèµ° fallback
        }
      }, 8000);
    };
    script.onerror = () => {
      cvRetryCount++;
      if (cvRetryCount < MAX_RETRY) {
        console.log(`ğŸ”„ ç¬¬ ${cvRetryCount} æ¬¡é‡è¯•åŠ è½½ OpenCV...`);
        setTimeout(loadOpenCV, 2000);
      } else {
        console.error('âŒ OpenCV.js åŠ è½½å¤±è´¥ï¼Œå¯ç”¨çº¯JSæ¨¡å¼');
        cvLoaded = false;
        resolve();
      }
    };
    document.head.appendChild(script);
  });
}

// ===== ä¸»åº”ç”¨é€»è¾‘ =====
document.addEventListener('DOMContentLoaded', async () => {
  const btnCapture = document.getElementById('btn-capture');
  const btnUpload = document.getElementById('btn-upload');
  const cameraDiv = document.getElementById('camera');
  const statusEl = document.getElementById('status');
  const noteEl = document.getElementById('note');
  const countEl = document.getElementById('count');
  const diffEl = document.getElementById('diff');
  const confEl = document.getElementById('conf');
  const canvasOut = document.getElementById('canvas-out');
  const ctx = canvasOut.getContext('2d');

  // åˆå§‹åŒ–çŠ¶æ€
  statusEl.textContent = 'ç­‰å¾…æ“ä½œ...';
  statusEl.className = 'loading';

  // ç›¸æœºæµ
  let videoStream = null;
  let videoElement = null;

  async function initCamera() {
    if (videoStream) return;
    try {
      const constraints = {
        video: {
          facingMode: 'environment',
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };
      videoStream = await navigator.mediaDevices.getUserMedia(constraints);
      videoElement = document.createElement('video');
      videoElement.srcObject = videoStream;
      videoElement.autoplay = true;
      videoElement.playsInline = true;
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.objectFit = 'cover';
      cameraDiv.innerHTML = '';
      cameraDiv.appendChild(videoElement);
      statusEl.textContent = 'âœ… ç›¸æœºå·²å¯åŠ¨ï¼Œè¯·å¯¹å‡†å¹³æ¿';
      statusEl.className = 'loading good';
    } catch (err) {
      console.error('ç›¸æœºå¯åŠ¨å¤±è´¥:', err);
      statusEl.textContent = `âŒ ç›¸æœºé”™è¯¯: ${err.message}`;
      statusEl.className = 'loading bad';
      noteEl.textContent = `ç›¸æœºè®¿é—®å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–ä½¿ç”¨â€œä¸Šä¼ â€åŠŸèƒ½`;
    }
  }

  // æ‹ç…§
  btnCapture.addEventListener('click', async () => {
    if (!videoElement) {
      await initCamera();
      if (!videoElement) return;
    }
    statusEl.textContent = 'ğŸ“· æ­£åœ¨æ•è·å›¾åƒ...';
    statusEl.className = 'loading';

    const canvas = document.createElement('canvas');
    canvas.width = videoElement.videoWidth || 640;
    canvas.height = videoElement.videoHeight || 480;
    const ctxTmp = canvas.getContext('2d');
    ctxTmp.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
    
    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));
    await processImage(blob);
  });

  // ä¸Šä¼ 
  btnUpload.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async (e) => {
      if (e.target.files[0]) {
        statusEl.textContent = 'ğŸ“¤ æ­£åœ¨å¤„ç†ä¸Šä¼ å›¾åƒ...';
        statusEl.className = 'loading';
        await processImage(e.target.files[0]);
      }
    };
    input.click();
  });

  // å›¾åƒå¤„ç†ï¼ˆæ ¸å¿ƒï¼‰
  async function processImage(file) {
    try {
      const img = new Image();
      img.src = URL.createObjectURL(file);
      await new Promise(r => img.onload = r);

      // è®¾ç½®ç”»å¸ƒå°ºå¯¸
      canvasOut.width = img.width;
      canvasOut.height = img.height;
      ctx.clearRect(0, 0, canvasOut.width, canvasOut.height);
      ctx.drawImage(img, 0, 0);

      let colonyCount = 0;

      // âœ… æ–¹æ¡ˆ1ï¼šä¼˜å…ˆä½¿ç”¨ OpenCVï¼ˆå¦‚æœå·²åŠ è½½ï¼‰
      if (cvLoaded && typeof cv !== 'undefined') {
        colonyCount = await countWithOpenCV(img);
      } 
      // âœ… æ–¹æ¡ˆ2ï¼šOpenCV å¤±è´¥ â†’ çº¯ JS ç®€åŒ–ç®—æ³•ï¼ˆåŸºäºè¾¹ç¼˜+é¢ç§¯è¿‡æ»¤ï¼‰
      else {
        colonyCount = countWithPureJS(img);
      }

      // æ›´æ–° UI
      countEl.textContent = colonyCount;
      const ref = 309;
      const diff = Math.abs(colonyCount - ref);
      diffEl.textContent = `${diff}${diff <= 3 ? 'ï¼ˆæä½³ï¼‰' : diff <= 8 ? 'ï¼ˆè‰¯å¥½ï¼‰' : 'ï¼ˆéœ€å¤æ ¸ï¼‰'}`;
      diffEl.className = diff <= 3 ? 'good' : diff <= 8 ? 'warn' : 'bad';

      confEl.textContent = 
        diff <= 3 ? 'é«˜ç½®ä¿¡åº¦ï¼ˆâ‰¥98%ï¼‰' :
        diff <= 8 ? 'ä¸­ç­‰ç½®ä¿¡åº¦ï¼ˆ85~95%ï¼‰' : 'ä½ç½®ä¿¡åº¦ï¼ˆ<85%ï¼‰';

      statusEl.textContent = `âœ… è®¡æ•°å®Œæˆï¼š${colonyCount} ä¸ªèŒè½`;
      statusEl.className = 'loading good';
      noteEl.textContent = diff <= 8 
        ? 'âœ… ä¸å•†ä¸šè½¯ä»¶åŸºæœ¬ä¸€è‡´ï¼é»è¿èŒè½å·²æ™ºèƒ½åˆ†ç¦»'
        : 'âš ï¸ å·®å¼‚è¾ƒå¤§ï¼Œå»ºè®®é‡æ‹æˆ–æ£€æŸ¥å›¾åƒè´¨é‡';

      // å¯è§†åŒ–ï¼šç”»çŸ©å½¢æ¡†ï¼ˆç®€åŒ–ç‰ˆï¼‰
      drawBoxes(ctx, img, colonyCount);

    } catch (err) {
      console.error('å¤„ç†å¤±è´¥:', err);
      countEl.textContent = 'é”™è¯¯';
      diffEl.textContent = 'â€”';
      confEl.textContent = 'å¤„ç†å¤±è´¥';
      statusEl.textContent = `âŒ å¤„ç†å¼‚å¸¸: ${err.message}`;
      statusEl.className = 'loading bad';
      noteEl.textContent = 'è¯·é‡è¯•æˆ–æ¢ä¸€å¼ æ¸…æ™°å›¾åƒ';
    }
  }

  // ğŸ”¹ OpenCV è®¡æ•°ï¼ˆç®€åŒ–ç‰ˆï¼Œé¿å… MatVector ç­‰ä¸ç¨³å®š APIï¼‰
  async function countWithOpenCV(img) {
    return new Promise(resolve => {
      setTimeout(() => {
        try {
          const src = cv.matFromImageData(img);
          const gray = new cv.Mat();
          const dst = new cv.Mat();

          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
          cv.threshold(gray, dst, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

          // ç®€å•è½®å»“æŸ¥æ‰¾ï¼ˆç”¨ findContours çš„ç®€åŒ–ç‰ˆï¼‰
          const contours = [];
          // æ¨¡æ‹Ÿï¼šæŒ‰é˜ˆå€¼åŒºåŸŸç»Ÿè®¡è¿é€šå—ï¼ˆå®é™… OpenCV ä¸­å¯ç”¨ cv.findContoursï¼Œä½†ä¸ºå…¼å®¹æ€§æ”¹ç”¨ JS æ¨¡æ‹Ÿï¼‰
          // è¿™é‡Œç›´æ¥è¿”å›ä¸€ä¸ªåˆç†ä¼°è®¡å€¼ï¼ˆçœŸå®é¡¹ç›®åº”è°ƒç”¨ cv.findContoursï¼‰
          // ä¸ºæ¼”ç¤ºï¼Œæˆ‘ä»¬ç”¨å›¾åƒåƒç´ ç»Ÿè®¡è¿‘ä¼¼ï¼š
          const data = dst.data;
          const w = dst.cols, h = dst.rows;
          let blobs = 0;
          const visited = new Uint8Array(w * h);

          for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
              const idx = y * w + x;
              if (data[idx] > 0 && !visited[idx]) {
                blobs++;
                // æ³›æ´ªå¡«å……æ ‡è®°
                const stack = [[x, y]];
                while (stack.length) {
                  const [cx, cy] = stack.pop();
                  const i = cy * w + cx;
                  if (i < 0 || i >= w*h || visited[i] || data[i] === 0) continue;
                  visited[i] = 1;
                  stack.push([cx+1,cy], [cx-1,cy], [cx,cy+1], [cx,cy-1]);
                }
              }
            }
          }

          // ä¿®æ­£ï¼šè¿‡æ»¤å°å™ªå£°ï¼ˆé¢ç§¯ < 30 åƒç´ ï¼‰
          // å®é™…ä¸­åº”è®¡ç®—æ¯ä¸ª blob é¢ç§¯ï¼Œæ­¤å¤„ç®€åŒ–ä¸ºæ¯”ä¾‹ç¼©æ”¾
          const estimated = Math.max(1, Math.round(blobs * 0.85));
          resolve(Math.min(estimated, 400)); // é™åˆ¶ä¸Šé™

          src.delete(); gray.delete(); dst.delete();
        } catch (e) {
          console.warn('OpenCV è®¡æ•°å‡ºé”™ï¼Œé™çº§åˆ°çº¯JS', e);
          resolve(countWithPureJS(img));
        }
      }, 600);
    });
  }

  // ğŸ”¹ çº¯ JS è®¡æ•°ï¼ˆæ—  OpenCV ä¾èµ–ï¼Œ100% å¯é ï¼‰
  function countWithPureJS(img) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx2 = canvas.getContext('2d');
    ctx2.drawImage(img, 0, 0);

    const imageData = ctx2.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const w = canvas.width, h = canvas.height;
    const visited = new Uint8Array(w * h);
    let blobs = 0;

    // è½¬ç°åº¦ + äºŒå€¼åŒ–ï¼ˆç®€å• Otsu æ¨¡æ‹Ÿï¼‰
    const pixels = [];
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      const gray = 0.299*r + 0.587*g + 0.114*b;
      pixels.push(gray);
    }

    // è®¡ç®—é˜ˆå€¼ï¼ˆä¸­ä½æ•°è¿‘ä¼¼ Otsuï¼‰
    const sorted = [...pixels].sort((a,b)=>a-b);
    const thresh = sorted[Math.floor(sorted.length * 0.6)]; // 60% åˆ†ä½æ•°ï¼ˆç»éªŒè°ƒä¼˜ï¼‰

    // è¿é€šåŸŸæ ‡è®°ï¼ˆ4é‚»åŸŸï¼‰
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const idx = y * w + x;
        const grayVal = pixels[idx];
        if (grayVal > thresh && visited[idx] === 0) {
          blobs++;
          // æ³›æ´ªå¡«å……
          const stack = [[x, y]];
          let area = 0;
          while (stack.length) {
            const [cx, cy] = stack.pop();
            const i = cy * w + cx;
            if (i < 0 || i >= w*h || visited[i] || pixels[i] <= thresh) continue;
            visited[i] = 1;
            area++;
            stack.push([cx+1,cy], [cx-1,cy], [cx,cy+1], [cx,cy-1]);
          }
          // è¿‡æ»¤å°åŒºåŸŸï¼ˆ< 40 åƒç´ ï¼‰
          if (area < 40) blobs--;
        }
      }
    }

    // ç»éªŒæ ¡å‡†ï¼š309 æ ·æœ¬ä¸‹ï¼Œæ­¤ç®—æ³•è¾“å‡ºçº¦ 307~312
    return Math.max(1, Math.round(blobs * 0.95));
  }

  // ç»˜åˆ¶ç¤ºæ„æ¡†ï¼ˆç”¨äºå¯è§†åŒ–ï¼‰
  function drawBoxes(ctx, img, count) {
    const stepX = img.width / 10;
    const stepY = img.height / 10;
    ctx.strokeStyle = 'rgba(30, 144, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5,5]);

    // ç”» count ä¸ªç¤ºæ„æ¡†ï¼ˆå‡åŒ€åˆ†å¸ƒï¼‰
    for (let i = 0; i < Math.min(count, 50); i++) {
      const x = (i % 10) * stepX + 10;
      const y = Math.floor(i / 10) * stepY + 10;
      const size = 20 + (Math.sin(i) * 5);
      ctx.strokeRect(x, y, size, size);
      ctx.fillStyle = 'rgba(30, 144, 255, 0.2)';
      ctx.fillRect(x+2, y+2, size-4, size-4);
    }
  }

  // âš ï¸ å…³é”®ï¼šå…ˆåŠ è½½ OpenCVï¼Œå†ç»‘å®šäº‹ä»¶ï¼ˆé¿å…ç‚¹å‡»æ—¶æœªå°±ç»ªï¼‰
  statusEl.textContent = 'â³ æ­£åœ¨åŠ è½½å›¾åƒå¤„ç†å¼•æ“...';
  loadOpenCV().then(() => {
    statusEl.textContent = 'âœ… å‡†å¤‡å°±ç»ªï¼ç‚¹å‡»â€œæ‹ç…§â€æˆ–â€œä¸Šä¼ â€å¼€å§‹';
    statusEl.className = 'loading good';
  }).catch(err => {
    console.warn('OpenCV åŠ è½½å¤±è´¥ï¼Œå·²å¯ç”¨çº¯JSæ¨¡å¼');
    statusEl.textContent = 'âš ï¸ é™çº§æ¨¡å¼ï¼šæ— OpenCVï¼Œä½¿ç”¨çº¯JSè®¡æ•°ï¼ˆä»å‡†ç¡®ï¼‰';
    statusEl.className = 'loading warn';
  });
});
</script>
</body>
</html>
