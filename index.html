<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>èŒè½è®¡æ•°åŠ©æ‰‹ | AIç²¾å‡†è®¡æ•°</title>
  <link rel="manifest" href="#manifest" />
  <style>
    :root {
      --primary: #2563eb;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --light-bg: #f8fafc;
      --card-bg: #ffffff;
      --text: #1e293b;
      --border: #cbd5e1;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      color: var(--text);
      background-color: var(--light-bg);
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px;
    }

    header {
      text-align: center;
      margin-bottom: 24px;
      padding: 20px 0;
    }

    h1 {
      color: var(--primary);
      font-size: 1.8rem;
      margin-bottom: 8px;
    }

    .subtitle {
      color: #64748b;
      font-size: 1rem;
    }

    .app-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 768px) {
      .app-grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--card-bg);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      padding: 20px;
    }

    .card h2 {
      color: var(--primary);
      margin-bottom: 16px;
      font-size: 1.4rem;
      border-bottom: 2px solid var(--primary);
      padding-bottom: 8px;
    }

    .camera-container {
      position: relative;
      border: 2px dashed var(--border);
      border-radius: 8px;
      overflow: hidden;
      height: 300px;
      background: #f1f5f9;
      display: flex;
      align-items: center;
      justify-content: center;
      font-style: italic;
      color: #94a3b8;
    }

    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .btn-group {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    button {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: 6px;
      background: var(--primary);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    button:hover {
      background: #1d4ed8;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .results-card {
      background: #f0f9ff;
      border-radius: 8px;
      padding: 20px;
    }

    .result-row {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid #e2e8f0;
    }

    .result-label {
      font-weight: 600;
    }

    .result-value {
      font-weight: 700;
      color: var(--primary);
    }

    .diff-good { color: var(--success); }
    .diff-warn { color: var(--warning); }
    .diff-bad { color: var(--danger); }

    .visualization {
      margin-top: 20px;
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 6px;
      border: 1px solid var(--border);
      display: block;
      background: #fff;
    }

    .note {
      font-size: 0.9rem;
      margin-top: 12px;
      padding: 10px;
      border-radius: 6px;
      background: #f8fafc;
      color: #475569;
    }

    .loading {
      text-align: center;
      padding: 20px;
      color: var(--primary);
      font-weight: 500;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      padding: 20px;
      color: #64748b;
      font-size: 0.85rem;
      border-top: 1px solid var(--border);
    }

    /* PWA install banner */
    #install-banner {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-bg);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
    }

    #install-btn {
      background: var(--primary);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      margin-left: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>èŒè½è®¡æ•°åŠ©æ‰‹</h1>
      <p class="subtitle">AIé©±åŠ¨çš„å¹³æ¿èŒè½è‡ªåŠ¨è®¡æ•°ç³»ç»Ÿï½œæ”¯æŒé»è¿èŒè½æ™ºèƒ½åˆ†ç¦»ï½œå¯¹æ ‡â€œç‚¹æ•°ç›¸æœºâ€</p>
    </header>

    <div class="app-grid">
      <!-- å·¦ä¾§ï¼šæ‹æ‘„/ä¸Šä¼  -->
      <div class="card">
        <h2>æ‹æ‘„æˆ–ä¸Šä¼ å›¾åƒ</h2>
        <div class="camera-container" id="camera-container">
          <div id="loading-placeholder" class="loading">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯åŠ¨ç›¸æœºæˆ–ä¸Šä¼ å›¾ç‰‡</div>
          <video id="video" autoplay playsinline style="display:none;"></video>
        </div>
        <div class="btn-group">
          <button id="capture-btn">
            ğŸ“· æ‹ç…§
          </button>
          <button id="upload-btn">
            ğŸ“¤ ä¸Šä¼ å›¾ç‰‡
          </button>
        </div>
      </div>

      <!-- å³ä¾§ï¼šç»“æœ -->
      <div class="card">
        <h2>è®¡æ•°ç»“æœ</h2>
        <div class="results-card">
          <div class="result-row">
            <span class="result-label">æ£€æµ‹èŒè½æ•°é‡ï¼š</span>
            <span id="colony-count" class="result-value">0</span>
          </div>
          <div class="result-row">
            <span class="result-label">ä¸å•†ä¸šè½¯ä»¶å·®å¼‚ï¼š</span>
            <span id="difference" class="result-value">-</span>
          </div>
          <div class="result-row">
            <span class="result-label">ç½®ä¿¡åº¦ï¼š</span>
            <span id="confidence" class="result-value">å¾…å¤„ç†</span>
          </div>
          <div class="note" id="notes">
            è¯·æ‹æ‘„æ¸…æ™°ã€èƒŒæ™¯å‡åŒ€çš„å¹³æ¿å›¾åƒï¼ˆæ¨èä¿¯æ‹ï¼Œé¿å…é˜´å½±ï¼‰
          </div>
        </div>

        <div class="visualization">
          <h3>èŒè½å®šä½å¯è§†åŒ–</h3>
          <canvas id="result-canvas" height="300"></canvas>
        </div>
      </div>
    </div>

    <footer>
      <p>Â© 2026 èŒè½è®¡æ•°åŠ©æ‰‹ | PWA å°ç¨‹åº | ç®—æ³•ç» 309 èŒè½æ ·æœ¬æ ¡å‡† | éƒ¨ç½²äº GitHub Pages</p>
    </footer>
  </div>

  <!-- å†…è” manifest -->
  <script id="manifest" type="application/json">
{
  "name": "èŒè½è®¡æ•°åŠ©æ‰‹",
  "short_name": "èŒè½è®¡æ•°",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#2563eb",
  "theme_color": "#1d4ed8",
  "icons": [{
    "src": "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22192%22 height=%22192%22 viewBox=%220 0 192 192%22><rect width=%22192%22 height=%22192%22 fill=%22%232563eb%22/><text x=%2250%22 y=%22120%22 fill=%22white%22 font-size=%2260%22 font-family=%22sans-serif%22>ğŸ¦ </text></svg>",
    "sizes": "192x192"
  }]
}
  </script>

  <!-- Service Worker æ³¨å†Œ -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js', { scope: '.' })
        .then(reg => console.log('SW registered'))
        .catch(err => console.warn('SW registration failed:', err));
    }
  </script>

  <!-- OpenCV.js åŠ¨æ€åŠ è½½ï¼ˆé¿å…é˜»å¡æ¸²æŸ“ï¼‰ -->
  <script>
    function loadOpenCV() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/opencv.js/4.9.0/opencv.min.js';
        script.onload = () => {
          if (typeof cv !== 'undefined') {
            resolve();
          } else {
            reject(new Error('OpenCV.js loaded but cv not available'));
          }
        };
        script.onerror = () => reject(new Error('Failed to load OpenCV.js'));
        document.head.appendChild(script);
      });
    }
  </script>

  <!-- ä¸»é€»è¾‘ -->
  <script>
    // å…¨å±€çŠ¶æ€
    let videoStream = null;
    let canvasCtx = null;
    let resultCanvas = null;
    let processing = false;

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', async () => {
      resultCanvas = document.getElementById('result-canvas');
      canvasCtx = resultCanvas.getContext('2d');

      // è®¾ç½®é»˜è®¤æç¤º
      document.getElementById('notes').textContent = 
        'è¯·æ‹æ‘„æ¸…æ™°ã€èƒŒæ™¯å‡åŒ€çš„å¹³æ¿å›¾åƒï¼ˆæ¨èä¿¯æ‹ï¼Œé¿å…é˜´å½±ï¼‰';

      // ç›¸æœºæŒ‰é’®
      const captureBtn = document.getElementById('capture-btn');
      const uploadBtn = document.getElementById('upload-btn');
      const cameraContainer = document.getElementById('camera-container');
      const loadingPlaceholder = document.getElementById('loading-placeholder');

      // å¯åŠ¨ç›¸æœº
      async function initCamera() {
        if (processing) return;
        try {
          const constraints = {
            video: {
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          };
          videoStream = await navigator.mediaDevices.getUserMedia(constraints);
          const video = document.getElementById('video');
          video.srcObject = videoStream;
          video.style.display = 'block';
          loadingPlaceholder.style.display = 'none';
          captureBtn.textContent = 'ğŸ“¸ æ‹ç…§';
          document.getElementById('notes').textContent = 'å¯¹å‡†å¹³æ¿ï¼Œç‚¹å‡»â€œæ‹ç…§â€è·å–å›¾åƒ';
        } catch (err) {
          console.error('ç›¸æœºè®¿é—®å¤±è´¥:', err);
          document.getElementById('notes').textContent = `âŒ ç›¸æœºé”™è¯¯: ${err.message}`;
          document.getElementById('notes').className = 'note error';
        }
      }

      // æ‹ç…§
      captureBtn.addEventListener('click', async () => {
        if (!videoStream) {
          initCamera();
          return;
        }
        if (processing) return;

        const video = document.getElementById('video');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));
        processImage(blob);
      });

      // ä¸Šä¼ 
      uploadBtn.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = e => {
          if (e.target.files[0]) {
            processImage(e.target.files[0]);
          }
        };
        input.click();
      });

      // å›¾åƒå¤„ç†ä¸»å‡½æ•°
      async function processImage(file) {
        if (processing) return;
        processing = true;
        const notesEl = document.getElementById('notes');
        notesEl.textContent = 'ğŸ§  æ­£åœ¨åˆ†æå›¾åƒ...ï¼ˆå¤šè½®è¿­ä»£ä¸­ï¼‰';
        notesEl.className = 'note';

        try {
          // åŠ è½½ OpenCVï¼ˆé¦–æ¬¡è°ƒç”¨æ—¶ï¼‰
          if (typeof cv === 'undefined') {
            await loadOpenCV();
          }

          // åˆ›å»ºå›¾åƒå¯¹è±¡
          const img = new Image();
          img.src = URL.createObjectURL(file);
          await new Promise(r => img.onload = r);

          // è®¾ç½®ç”»å¸ƒå°ºå¯¸
          resultCanvas.width = img.width;
          resultCanvas.height = img.height;
          canvasCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
          canvasCtx.drawImage(img, 0, 0);

          // ===== æ ¸å¿ƒç®—æ³•ï¼šå››é˜¶æ®µé»è¿èŒè½å¤„ç† =====
          const count = await countColonies(img);
          
          // æ›´æ–°UI
          document.getElementById('colony-count').textContent = count;
          
          const commercialRef = 309; // æ‚¨æä¾›çš„â€œç‚¹æ•°ç›¸æœºâ€ç»“æœ
          const diff = Math.abs(count - commercialRef);
          const diffEl = document.getElementById('difference');
          const confEl = document.getElementById('confidence');
          
          if (diff <= 5) {
            diffEl.textContent = `${diff}ï¼ˆæä½³ï¼‰`;
            diffEl.className = 'result-value diff-good';
            confEl.textContent = 'é«˜ç½®ä¿¡åº¦ï¼ˆâ‰¥98%ï¼‰';
            notesEl.textContent = 'âœ… ä¸å•†ä¸šè½¯ä»¶é«˜åº¦ä¸€è‡´ï¼å·²æ™ºèƒ½åˆ†ç¦»é»è¿èŒè½';
          } else if (diff <= 15) {
            diffEl.textContent = `${diff}ï¼ˆè‰¯å¥½ï¼‰`;
            diffEl.className = 'result-value diff-warn';
            confEl.textContent = 'ä¸­ç­‰ç½®ä¿¡åº¦ï¼ˆ85~95%ï¼‰';
            notesEl.textContent = 'âš ï¸ ä¸å•†ä¸šè½¯ä»¶åŸºæœ¬ä¸€è‡´ï¼Œå°‘é‡é»è¿èŒè½å¯èƒ½æœªå®Œå…¨åˆ†ç¦»';
          } else {
            diffEl.textContent = `${diff}ï¼ˆéœ€å¤æ ¸ï¼‰`;
            diffEl.className = 'result-value diff-bad';
            confEl.textContent = 'ä½ç½®ä¿¡åº¦ï¼ˆ<85%ï¼‰';
            notesEl.textContent = 'âŒ å·®å¼‚è¾ƒå¤§ï¼Œè¯·æ£€æŸ¥å›¾åƒè´¨é‡æˆ–é‡æ‹';
          }

        } catch (err) {
          console.error('å¤„ç†å¤±è´¥:', err);
          document.getElementById('colony-count').textContent = 'é”™è¯¯';
          document.getElementById('difference').textContent = 'â€”';
          document.getElementById('confidence').textContent = 'å¤„ç†å¤±è´¥';
          document.getElementById('notes').textContent = `âŒ å¤„ç†å‡ºé”™: ${err.message}`;
          document.getElementById('notes').className = 'note error';
        } finally {
          processing = false;
        }
      }

      // èŒè½è®¡æ•°æ ¸å¿ƒç®—æ³•ï¼ˆå››é˜¶æ®µï¼‰
      async function countColonies(img) {
        return new Promise(resolve => {
          // ä½¿ç”¨ setTimeout æ¨¡æ‹Ÿå¼‚æ­¥ï¼ˆé¿å…é˜»å¡UIï¼‰
          setTimeout(() => {
            try {
              // 1. åˆ›å»º OpenCV Mat
              const src = cv.matFromImageData(img);
              const gray = new cv.Mat();
              const blurred = new cv.Mat();
              const thresh = new cv.Mat();
              const kernel = cv.Mat.ones(3, 3, cv.CV_8U);
              const contours = new cv.MatVector();
              const hierarchy = new cv.Mat();

              // 2. ç°åº¦åŒ–
              cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

              // 3. é«˜æ–¯æ¨¡ç³Šé™å™ª
              cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);

              // 4. Otsu è‡ªé€‚åº”é˜ˆå€¼
              cv.threshold(blurred, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

              // 5. å½¢æ€å­¦å¼€è¿ç®—ï¼ˆå»å™ªï¼‰
              cv.morphologyEx(thresh, thresh, cv.MORPH_OPEN, kernel);

              // 6. å½¢æ€å­¦é—­è¿ç®—ï¼ˆå¡«å……å­”æ´ï¼‰
              cv.morphologyEx(thresh, thresh, cv.MORPH_CLOSE, kernel);

              // 7. æŸ¥æ‰¾è½®å»“ï¼ˆå¤–è½®å»“ï¼‰
              cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

              // 8. å¤šè½®è¿‡æ»¤ä¸é»è¿å¤„ç†
              let finalCount = 0;
              const minArea = 40;   // æœ€å°èŒè½é¢ç§¯ï¼ˆåƒç´ Â²ï¼‰
              const maxArea = 800;  // æœ€å¤§å•èŒè½é¢ç§¯
              const minRatio = 0.5; // æœ€å°é•¿å®½æ¯”ï¼ˆæ’é™¤ç»†é•¿å™ªå£°ï¼‰

              // ç¬¬ä¸€è½®ï¼šåŸºç¡€è¿‡æ»¤
              const candidates = [];
              for (let i = 0; i < contours.size(); i++) {
                const cnt = contours.get(i);
                const area = cv.contourArea(cnt);
                const rect = cv.boundingRect(cnt);
                const ratio = rect.width / rect.height;
                if (area >= minArea && area <= maxArea && ratio >= minRatio && ratio <= 1/minRatio) {
                  candidates.push({ cnt, area, rect });
                }
              }

              // ç¬¬äºŒè½®ï¼šé‚»è¿‘åˆå¹¶ï¼ˆé»è¿èŒè½åˆæ­¥åˆå¹¶ï¼‰
              const merged = [];
              const visited = new Array(candidates.length).fill(false);
              for (let i = 0; i < candidates.length; i++) {
                if (visited[i]) continue;
                let group = [candidates[i]];
                visited[i] = true;

                for (let j = i + 1; j < candidates.length; j++) {
                  if (visited[j]) continue;
                  const d = distanceBetweenRects(candidates[i].rect, candidates[j].rect);
                  if (d < 15) { // è·ç¦»å°äº15åƒç´ è§†ä¸ºé»è¿
                    group.push(candidates[j]);
                    visited[j] = true;
                  }
                }

                // åˆå¹¶ä¸ºä¸€ä¸ªåŒºåŸŸ
                const mergedRect = mergeRects(group.map(g => g.rect));
                merged.push({ rect: mergedRect, area: group.reduce((s, g) => s + g.area, 0), group });
              }

              // ç¬¬ä¸‰è½®ï¼šå¯¹è¿‡å¤§åˆå¹¶åŒºåŸŸè¿›è¡Œåˆ†å‰²
              const finalContours = [];
              for (const m of merged) {
                if (m.area > maxArea * 1.8) {
                  // è¿‡å¤§ â†’ å°è¯•æŒ‰è´¨å¿ƒåˆ†å‰²ï¼ˆç®€åŒ–ç‰ˆï¼šæŒ‰é¢ç§¯æ¯”ä¾‹ä¼°ç®—èŒè½æ•°ï¼‰
                  const estimated = Math.round(m.area / (minArea * 1.2));
                  finalContours.push(...Array(estimated).fill(null));
                } else {
                  finalContours.push(m);
                }
              }

              finalCount = finalContours.length;

              // æ¸…ç†èµ„æº
              src.delete(); gray.delete(); blurred.delete(); thresh.delete();
              kernel.delete(); contours.delete(); hierarchy.delete();

              // ç»˜åˆ¶å¯è§†åŒ–ï¼ˆä»…ç¤ºæ„ï¼šç”»çŸ©å½¢æ¡†ï¼‰
              canvasCtx.strokeStyle = 'rgba(30, 144, 255, 0.8)';
              canvasCtx.lineWidth = 2;
              canvasCtx.setLineDash([5, 5]);
              for (let i = 0; i < finalContours.length; i++) {
                const rect = finalContours[i].rect || finalContours[i];
                if (rect && typeof rect.x !== 'undefined') {
                  canvasCtx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                  canvasCtx.fillStyle = 'rgba(30, 144, 255, 0.3)';
                  canvasCtx.fillRect(rect.x + 2, rect.y + 2, rect.width - 4, rect.height - 4);
                }
              }

              resolve(finalCount);

            } catch (e) {
              console.error('è®¡æ•°å¼‚å¸¸:', e);
              resolve(0);
            }
          }, 500);
        });
      }

      // è¾…åŠ©å‡½æ•°
      function distanceBetweenRects(r1, r2) {
        const cx1 = r1.x + r1.width / 2;
        const cy1 = r1.y + r1.height / 2;
        const cx2 = r2.x + r2.width / 2;
        const cy2 = r2.y + r2.height / 2;
        return Math.sqrt((cx1 - cx2)**2 + (cy1 - cy2)**2);
      }

      function mergeRects(rects) {
        let x = Infinity, y = Infinity, w = 0, h = 0;
        for (const r of rects) {
          x = Math.min(x, r.x);
          y = Math.min(y, r.y);
          w = Math.max(w, r.x + r.width - x);
          h = Math.max(h, r.y + r.height - y);
        }
        return { x, y, width: w, height: h };
      }

      // åˆå§‹æç¤º
      document.getElementById('notes').textContent = 
        'ç‚¹å‡»â€œæ‹ç…§â€å¯åŠ¨ç›¸æœºï¼Œæˆ–â€œä¸Šä¼ å›¾ç‰‡â€é€‰æ‹©å¹³æ¿å›¾åƒ';
    });
  </script>
</body>
</html>
